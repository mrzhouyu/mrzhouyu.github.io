<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>YuChou</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="YuChou">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="YuChou">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="YuChou">
  
    <link rel="alternate" href="/atom.xml" title="YuChou" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/plugin/bganimation/bg.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="http://149.248.3.74/Photos/titleImage/AF359E06C1819F0FA30D32DA9F0E8EB6.png">
    <h2 class="author">YuChou</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>17</strong><br>文章</div></a>
      <a href="/categories"><div><strong>11</strong><br>分类</div></a>
      <a href="/tags"><div><strong>16</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives/" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories/" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags/" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main">
  
    <article id="post-EMQ初体验" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/08/EMQ初体验/" class="article-date">
  <time class="post-time" datetime="2019-04-08T14:33:00.000Z" itemprop="datePublished">
    <span class="post-month">4月</span><br/>
    <span class="post-day">08</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/08/EMQ初体验/">EMQ初体验</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/消息队列/">消息队列</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>想走IOT哪有不了解EMQ的道理，EMQ (Erlang/Enterprise/Elastic MQTT Broker) 是基于 Erlang/OTP 平台开发的开源物联网 MQTT 消息服务器。</p>
<p><em>MQTT<strong>(</strong>消息队列遥测传输)是ISO 标准(ISO/IEC PRF 20922)下基于发布/订阅范式的消息协议。它工作在 <a href="https://baike.baidu.com/item/TCP%2FIP%E5%8D%8F%E8%AE%AE%E6%97%8F" target="_blank" rel="noopener">TCP/IP协议族</a>上，是为硬件性能低下的远程设备以及网络状况糟糕的情况下而设计的发布/订阅型消息协议，为此，它需要一个<a href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6" target="_blank" rel="noopener">消息中间件</a> 。</em></p>
<p>所以，这岂不是非常符合物联网需要降低硬件成本又需要应对复杂的多维网络环境的要求。目前公司项目有这方面的要求。对接安卓设备需要通过消息订阅，在这里记录下EMQ的初次体验，后面自己在详细理解MQTT协议本身和更上层的RabbitMQ。</p>
<h4 id="1-安装环境"><a href="#1-安装环境" class="headerlink" title="1.安装环境"></a>1.安装环境</h4><p>虚拟机，ubuntu16.04</p>
<h4 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h4><ul>
<li>下载链接：wget <a href="http://emqtt.com/static/brokers/emqttd-ubuntu16.04-v2.3.9_amd64.deb" target="_blank" rel="noopener">http://emqtt.com/static/brokers/emqttd-ubuntu16.04-v2.3.9_amd64.deb</a></li>
</ul>
<p><img src="http://149.248.3.74/EMQ/%e4%b8%8b%e8%bd%bd.jpg" alt="下载"></p>
<ul>
<li>安装：sudo dpkg -i emqttd-ubuntu16.04_v2.0_amd64.deb</li>
</ul>
<p><img src="http://149.248.3.74/EMQ/%e8%a7%a3%e5%8e%8b%e5%ae%89%e8%a3%85.jpg" alt="解压安装"></p>
<ul>
<li>启动：sudo service emqttd start</li>
</ul>
<p><img src="http://149.248.3.74/EMQ/%e5%90%af%e5%8a%a8%e6%9c%8d%e5%8a%a1%e5%99%a8.jpg" alt="启动"></p>
<ul>
<li>查看状态：sudo service emqttd status</li>
</ul>
<p><img src="http://149.248.3.74/EMQ/%e6%9f%a5%e7%9c%8b%e8%ae%be%e5%a4%87%e5%85%81%e8%ae%b8%e7%8a%b6%e6%80%81.jpg" alt="查看设备状态"></p>
<ul>
<li>打开默认端口防火墙</li>
</ul>
<p><img src="http://149.248.3.74/EMQ/%e6%89%93%e5%bc%80%e8%99%9a%e6%8b%9f%e6%9c%ba%e9%98%b2%e7%81%ab%e5%a2%99%e5%85%81%e8%ae%b8%e4%b8%bb%e6%9c%ba%e8%ae%bf%e9%97%ae.jpg" alt="允许端口访问"></p>
<h4 id="3-仪表盘登陆界面"><a href="#3-仪表盘登陆界面" class="headerlink" title="3.仪表盘登陆界面"></a>3.仪表盘登陆界面</h4><ul>
<li>登录界面</li>
</ul>
<p><img src="http://149.248.3.74/EMQ/%e9%a6%96%e6%ac%a1%e7%99%bb%e9%99%86%e7%95%8c%e9%9d%a2.jpg" alt="登录界面"></p>
<ul>
<li>进入主界面</li>
</ul>
<p><img src="http://149.248.3.74/EMQ/%e7%ae%a1%e7%90%86%e7%95%8c%e9%9d%a2.jpg" alt="主界面"></p>
<h4 id="4-初体验"><a href="#4-初体验" class="headerlink" title="4.初体验"></a>4.初体验</h4><ul>
<li>科学上网下载谷歌商城插件<a href="https://chrome.google.com/webstore/detail/mqttbox/kaajoficamnjijhkeomgfljpicifbkaf?hl=zh-CN" target="_blank" rel="noopener">MQTTBox</a> ,安装完成</li>
<li>打开插件，建立MQTT连接，指定连接相关信息，包括连接名称（可以随意输入）、协议（选择mqtt/tcp）和主机地址（安装在本地，MQTT缺省端口为1883，所以输入127.0.0.1:1883），然后单击“Save”保存。连接中一些别的选项先保持缺省值，读者对MQTT协议比较熟悉之后，就可以了解这些选项的意义。：</li>
</ul>
<p><img src="http://149.248.3.74/EMQ/%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e8%ae%a2%e9%98%85%e5%86%85%e5%ae%b9.jpg" alt="创建连接"></p>
<ul>
<li>保存成功后进入如下的界面，接下来可以开始测试消息发布和订阅。如下图所示，绿色“Connected”按钮表明当前MQTT连接已经成功。首先我们开启一个订阅，如下图所示。“Topic to subscribe”里填入要订阅的主题“windows”；“QoS”字段选择“0 - Almost Once”；然后点击“Subscribe”按钮。设置好订阅的主题后，在发布这边输入如下的信息。“Topic to publish”中输入“windows”，这里输入的主题的名字必须和订阅那里的输入相同；“QoS”中选择“0 - Almost Once”；“Payload”中输入任何内容都可以，如下图所示输入了一组JSON字符。在订阅端就会收到由服务器端转发的消息内容</li>
</ul>
<p><img src="http://149.248.3.74/EMQ/%e5%ae%9e%e7%8e%b0%e8%bf%87%e7%a8%8b.jpg" alt="实现过程"></p>
<ul>
<li>查看仪表盘消息记录：</li>
</ul>
<p><img src="http://149.248.3.74/EMQ/%e6%8a%95%e9%80%92%e6%b6%88%e6%81%af%e8%ae%b0%e5%bd%95.jpg" alt=""></p>
<h4 id="5-EMQ默认占用端口"><a href="#5-EMQ默认占用端口" class="headerlink" title="5.EMQ默认占用端口"></a>5.EMQ默认占用端口</h4><table>
<thead>
<tr>
<th>1883</th>
<th>MQTT 协议端口</th>
</tr>
</thead>
<tbody>
<tr>
<td>8883</td>
<td>MQTT/SSL 端口</td>
</tr>
<tr>
<td>8083</td>
<td>MQTT/WebSocket 端口</td>
</tr>
<tr>
<td>8080</td>
<td>HTTP API 端口</td>
</tr>
<tr>
<td>18083</td>
<td>Dashboard 管理控制台端口</td>
</tr>
</tbody>
</table>
<hr>
<p>参考地址：<a href="https://www.jianshu.com/p/e5cf0c1fd55c" target="_blank" rel="noopener">https://www.jianshu.com/p/e5cf0c1fd55c</a></p>
<p><a href="http://www.cnblogs.com/sxkgeek/p/9140180.html" target="_blank" rel="noopener">http://www.cnblogs.com/sxkgeek/p/9140180.html</a></p>
<p><a href="https://developer.emqx.io/docs/emq/v3/cn/" target="_blank" rel="noopener">https://developer.emqx.io/docs/emq/v3/cn/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/08/EMQ初体验/" data-id="cju9u14tq0000uohzehbp9pfw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MQTT、EMQ/">MQTT、EMQ</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-python协程" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/08/python协程/" class="article-date">
  <time class="post-time" datetime="2019-04-07T16:07:07.000Z" itemprop="datePublished">
    <span class="post-month">4月</span><br/>
    <span class="post-day">08</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/08/python协程/">python协程</a>
    </h1>
  

        <div>
          
          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/08/python协程/" data-id="cju9u14ul000nuohz7922z70m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-window下Redis安装配置" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/05/window下Redis安装配置/" class="article-date">
  <time class="post-time" datetime="2019-04-05T11:49:40.000Z" itemprop="datePublished">
    <span class="post-month">4月</span><br/>
    <span class="post-day">05</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/05/window下Redis安装配置/">window下Redis安装配置</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>不写分布式爬虫后，差不多两年没接触redis了，公司貌似很多项目都用redis做消息队列，先装上，最近在仔细研究Python并发这块，看看能不能有实例中用得上，好好复习下。</p>
<h3 id="redis优点"><a href="#redis优点" class="headerlink" title="redis优点"></a>redis优点</h3><ul>
<li>支持多种性数据类型：字符串、列表、散列、集合、有序集合</li>
<li>单线程，避免了多线程上下文切换</li>
<li>基于内存，速度快、持久化</li>
<li>分布式，读写分离</li>
<li>…….</li>
</ul>
<h4 id="1-环境"><a href="#1-环境" class="headerlink" title="1.环境"></a>1.环境</h4><ul>
<li>win10 64位操作系统</li>
</ul>
<h4 id="2-下载安装包"><a href="#2-下载安装包" class="headerlink" title="2.下载安装包"></a>2.下载安装包</h4><p><a href="https://github.com/MicrosoftArchive/redis/releases/download/win-3.2.100/Redis-x64-3.2.100.msi" target="_blank" rel="noopener">https://github.com/MicrosoftArchive/redis/releases/download/win-3.2.100/Redis-x64-3.2.100.msi</a></p>
<h4 id="3-点击安装"><a href="#3-点击安装" class="headerlink" title="3.点击安装"></a>3.点击安装</h4><ul>
<li>打钩：Add the Redis installation folder to the PATH…… </li>
<li>打钩：Add an exception to the Windows Firewall 允许外部访问</li>
<li>端口号可以默认</li>
<li>最大内存（Set the Max Memory limit）: 不是真的生产环境默认100M即可</li>
</ul>
<h4 id="4-修改密码"><a href="#4-修改密码" class="headerlink" title="4.修改密码"></a>4.修改密码</h4><p>在安装目录下找到<strong>redis.windows-service.conf</strong>文件，用编辑器打开，在# requirepass foobared下增加密码：requirepass 666666</p>
<h4 id="5-启动使得密码生效"><a href="#5-启动使得密码生效" class="headerlink" title="5.启动使得密码生效"></a>5.启动使得密码生效</h4><ul>
<li>访问：由于是刚刚安装的，默认是启动的。win+r 打开命令窗口，输入redis-cli (由于前面安装过程中已经添加了环境变量，这里可以通过redis客户端直接访问)，此时不需要输入密码，就可以使用数据库，例如 <code>set k &quot;Hello World&quot;</code> 确定，再执行  <code>get k</code>确定即可得到 “Hello World”的值。</li>
<li>使得密码生效：由于一开始服务器是安装时候已经启动的，密码没有生效，所以需要重启redis服务器并且使得密码生效。1.鼠标拉到桌面底部任务栏右键—进入 任务管理器—点击 服务，可以看到Redis正在运行，右键Redis，重新启动。2.重新利用redis-cli访问数据库，，执行<code>set k &quot;Hello World&quot;</code> , 返回 <code>(error) ERR Client sent AUTH</code>, 输入<code>auth 666666</code>确定，再次<code>set k &quot;Hello World&quot;</code>，返回 <code>ok</code>，密码设置成功。</li>
</ul>
<hr>
<p>有机会补充使用会踩得坑。。。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/05/window下Redis安装配置/" data-id="cju9u14v10011uohzlm4nl4qw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/">Redis</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-Python多线程" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/05/Python多线程/" class="article-date">
  <time class="post-time" datetime="2019-04-05T11:05:13.000Z" itemprop="datePublished">
    <span class="post-month">4月</span><br/>
    <span class="post-day">05</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/05/Python多线程/">Python多线程</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="关于Python多线程的概述"><a href="#关于Python多线程的概述" class="headerlink" title="关于Python多线程的概述"></a>关于Python多线程的概述</h3><p>由于GIL的存在，Python的多线程在CPU密集型任务并没有多大的优势，任何Python线程执行之前必须先获取GIL锁，然后每执行100条字节码解释器会释放锁，让其他线程有机会执行，阻塞时期的其他线程没有太大机会去占用其他CPU的资源，而是会阻塞等待当前CPU的线程执行完，对于多核并没有什么卵用。但是，对于I/O密集型任务，多线程还是有用的，比如爬虫，很多时候都是等待网站返回、等待网页解析，而这个等待的时间CPU是空闲的，此时可以将CPU的资源供其他I/O任务运行，充分利用单核资源。值得注意的是，Python的GIL并不是Python语言固有的特点，而是因为Python解释器–CPython引入的概念，Python解释器有CPython、PyPy、Psyco，Python本身完全可以不依赖于GIL，因为大部分默认的Python解释器环境是CPython，被误解为GIL是Python本身的缺陷。</p>
<p>另外多核CPU多线程可能会比单线处理总任务的时间更长，比如，有CPU1, CPU2, 有线程A，B，C，初始时期线程A在CPU1上执行，当A释放锁后，处于CPU2的C线程被唤醒，准备执行，可是由于上一个线程的释放锁到下一个线程的加锁，时间极其短，C准备取锁执行时候，处于CPU1的线程B提前拿到了锁，开始执行，C线程只好继续等待调度，如此反复，浪费时间。</p>
<h4 id="1-threading介绍"><a href="#1-threading介绍" class="headerlink" title="1.threading介绍"></a>1.threading介绍</h4><blockquote>
<p><strong>threading</strong>用于提供线程相关的操作，线程是应用程序中工作的最小单元。python当前版本的多线程库没有实现优先级、线程组，线程也不能被停止、暂停、恢复、中断。</p>
<p><strong>threading模块提供的类：</strong>  　　Thread, Lock, Rlock, Condition, [Bounded]Semaphore, Event, Timer, local。</p>
<p><strong>threading 模块提供的常用方法：</strong><br>　　threading.currentThread(): 返回当前的线程变量。<br>　　threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。<br>　　threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。</p>
<p><strong>threading 模块提供的常量：</strong></p>
<p>　　threading.TIMEOUT_MAX 设置threading全局超时时间。</p>
</blockquote>
<h4 id="2-Thread类"><a href="#2-Thread类" class="headerlink" title="2.Thread类"></a>2.Thread类</h4><blockquote>
<p><strong>构造方法：</strong> <em>Thread(group=None, target=None, name=None, args=(), kwargs={})</em> </p>
<p>　　group: 线程组，目前还没有实现，库引用中提示必须是None；<br>　　target: 要执行的方法；<br>　　name: 线程名；<br>　　args/kwargs: 要传入方法的参数。</p>
<p><strong>实例方法：</strong> 　　isAlive(): 返回线程是否在运行。正在运行指启动后、终止前。<br>　　get/setName(name): 获取/设置线程名。 </p>
<p>　　start():  线程准备就绪，等待CPU调度<br>　　is/setDaemon(bool): 获取/设置是后台线程（默认前台线程（False））。（在start之前设置）</p>
<p>　　　　如果是后台线程，主线程执行过程中，后台线程也在进行，主线程执行完毕后，后台线程不论成功与否，主线程和后台线程均停止<br>       　　如果是前台线程，主线程执行过程中，前台线程也在进行，主线程执行完毕后，等待前台线程也执行完成后，程序停止<br>　　start(): 启动线程。<br>　　join([timeout]): 阻塞当前上下文环境的线程，直到调用此方法的线程终止或到达指定的timeout（可选参数）。</p>
</blockquote>
<h4 id="3-Python多线程的两种使用方法"><a href="#3-Python多线程的两种使用方法" class="headerlink" title="3.Python多线程的两种使用方法"></a>3.Python多线程的两种使用方法</h4><h5 id="3-1-重写类方法"><a href="#3-1-重写类方法" class="headerlink" title="3.1 重写类方法"></a>3.1 重写类方法</h5><p>3.1.1 类方法重写代码块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, lang)</span>:</span></span><br><span class="line">        super(MyThread, self).__init__()</span><br><span class="line">        self.lang = lang</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># s = random.randint(1, 3)</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        print(<span class="string">"I Love &#123;:&lt;10&#125; Time: &#123;&#125;  ThreadName: &#123;:^&#125;"</span>.format(self.lang, datetime.datetime.now(), threading.Thread().name))</span><br></pre></td></tr></table></figure>
<p>3.1.2 不设置deamon和join：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    lang = [<span class="string">"Python"</span>, <span class="string">"Java"</span>, <span class="string">"PHP"</span>, <span class="string">"Golang"</span>, <span class="string">"C++"</span>, <span class="string">"C"</span>, <span class="string">"Julia"</span>]</span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> lang:</span><br><span class="line">        T = MyThread(lang=l)</span><br><span class="line">        <span class="comment"># T.setDaemon(True)</span></span><br><span class="line">        T.start()</span><br><span class="line">    <span class="comment"># T.join()</span></span><br><span class="line">    print(<span class="string">"主线程退出，time: %s"</span> % datetime.datetime.now())</span><br></pre></td></tr></table></figure>
<p>console: 主进程提前于子进程输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">主线程退出，time: 2019-04-07 20:37:47.847619</span><br><span class="line">I Love Python     Time: 2019-04-07 20:37:49.846555  ThreadName: Thread-8</span><br><span class="line">I Love C++        Time: 2019-04-07 20:37:49.852451  ThreadName: Thread-9</span><br><span class="line">I Love Java       Time: 2019-04-07 20:37:49.852451  ThreadName: Thread-10</span><br><span class="line">I Love Golang     Time: 2019-04-07 20:37:49.852932  ThreadName: Thread-11</span><br><span class="line">I Love Julia      Time: 2019-04-07 20:37:49.853937  ThreadName: Thread-12</span><br><span class="line">I Love C          Time: 2019-04-07 20:37:49.854098  ThreadName: Thread-13</span><br><span class="line">I Love PHP        Time: 2019-04-07 20:37:49.854098  ThreadName: Thread-14</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p>3.1.3 设置deamon：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    lang = [<span class="string">"Python"</span>, <span class="string">"Java"</span>, <span class="string">"PHP"</span>, <span class="string">"Golang"</span>, <span class="string">"C++"</span>, <span class="string">"C"</span>, <span class="string">"Julia"</span>]</span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> lang:</span><br><span class="line">        T = MyThread(lang=l)</span><br><span class="line">        T.setDaemon(<span class="keyword">True</span>)</span><br><span class="line">        T.start()</span><br><span class="line">    <span class="comment"># T.join()</span></span><br><span class="line">    print(<span class="string">"主线程退出，time: %s"</span> % datetime.datetime.now())</span><br></pre></td></tr></table></figure>
<p>console：只要主进程结束，不管子进程如何直接退出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主线程退出，time: 2019-04-07 20:39:03.144132</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p>3.1.4 设置join：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    threadPool = []</span><br><span class="line">    lang = [<span class="string">"Python"</span>, <span class="string">"Java"</span>, <span class="string">"PHP"</span>, <span class="string">"Golang"</span>, <span class="string">"C++"</span>, <span class="string">"C"</span>, <span class="string">"Julia"</span>]</span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> lang:</span><br><span class="line">        T = MyThread(lang=l)</span><br><span class="line">        threadPool.append(T)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threadPool:</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threadPool:</span><br><span class="line">        t.join()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"主线程退出，time: %s"</span> % datetime.datetime.now())</span><br></pre></td></tr></table></figure>
<p>console：子进程执行完，主进程退出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I Love Golang     Time: 2019-04-07 20:46:09.863986  ThreadName: Thread-8</span><br><span class="line">I Love Julia      Time: 2019-04-07 20:46:09.864122  ThreadName: Thread-9</span><br><span class="line">I Love C++        Time: 2019-04-07 20:46:09.864122  ThreadName: Thread-10</span><br><span class="line">I Love Java       Time: 2019-04-07 20:46:09.865120  ThreadName: Thread-11</span><br><span class="line">I Love C          Time: 2019-04-07 20:46:09.865120  ThreadName: Thread-12</span><br><span class="line">I Love Python     Time: 2019-04-07 20:46:09.865120  ThreadName: Thread-13</span><br><span class="line">I Love PHP        Time: 2019-04-07 20:46:09.866113  ThreadName: Thread-14</span><br><span class="line">主线程退出，time: 2019-04-07 20:46:09.866113</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p>如上所有子进程输出并没有间隔两秒，可见当某一个子进程处于等待时期，其他子进程迅速开启，以此类推。</p>
<h5 id="3-2-使用Thread类"><a href="#3-2-使用Thread类" class="headerlink" title="3.2 使用Thread类"></a>3.2 使用Thread类</h5><p>3.2.1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(language)</span>:</span></span><br><span class="line">    s = random.randint(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">    time.sleep(s)</span><br><span class="line">    print(<span class="string">"I Love &#123;:&lt;10&#125; Time: &#123;&#125;  ThreadName: &#123;:^&#125;"</span>.format(language, datetime.datetime.now(), threading.current_thread().name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    threadPool = []</span><br><span class="line">    lang = [<span class="string">"Python"</span>, <span class="string">"Java"</span>, <span class="string">"PHP"</span>, <span class="string">"Golang"</span>, <span class="string">"C++"</span>, <span class="string">"C"</span>, <span class="string">"Julia"</span>]</span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> lang:</span><br><span class="line">        T = threading.Thread(target=func, args=(l, ))</span><br><span class="line">        threadPool.append(T)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threadPool:</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threadPool:</span><br><span class="line">        t.join()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"主线程退出，time: %s"</span> % datetime.datetime.now())</span><br></pre></td></tr></table></figure>
<p>console: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I Love Python     Time: 2019-04-07 20:59:02.136552  ThreadName: Thread-1</span><br><span class="line">I Love C++        Time: 2019-04-07 20:59:02.142802  ThreadName: Thread-5</span><br><span class="line">I Love Julia      Time: 2019-04-07 20:59:02.142802  ThreadName: Thread-7</span><br><span class="line">I Love PHP        Time: 2019-04-07 20:59:03.139293  ThreadName: Thread-3</span><br><span class="line">I Love C          Time: 2019-04-07 20:59:04.137688  ThreadName: Thread-6</span><br><span class="line">I Love Golang     Time: 2019-04-07 20:59:04.137688  ThreadName: Thread-4</span><br><span class="line">I Love Java       Time: 2019-04-07 20:59:05.139252  ThreadName: Thread-2</span><br><span class="line">主线程退出，time: 2019-04-07 20:59:05.139708</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p>注意：threading.current_thread().name 和 threading.Thread().name方法的区别</p>
<h4 id="4-线程锁"><a href="#4-线程锁" class="headerlink" title="4.线程锁"></a>4.线程锁</h4><p>当多个线程访问同一个资源有可能造成混乱，此时就需要锁来规避可能造成的混乱。</p>
<blockquote>
<p>Lock（指令锁）是可用的最低级的同步指令。Lock处于锁定状态时，不被特定的线程拥有。Lock包含两种状态——锁定和非锁定，以及两个基本的方法。</p>
<p>可以认为Lock有一个锁定池，当线程请求锁定时，将线程至于池中，直到获得锁定后出池。池中的线程处于状态图中的同步阻塞状态。</p>
<p>RLock（可重入锁）是一个可以被同一个线程请求多次的同步指令。RLock使用了“拥有的线程”和“递归等级”的概念，处于锁定状态时，RLock被某个线程拥有。拥有RLock的线程可以再次调用acquire()，释放锁时需要调用release()相同次数。</p>
<p>可以认为RLock包含一个锁定池和一个初始值为0的计数器，每次成功调用 acquire()/release()，计数器将+1/-1，为0时锁处于未锁定状态。</p>
<p><strong>简言之：Lock属于全局，Rlock属于线程。</strong></p>
<p><strong>构造方法：</strong> Lock()，Rlock（）,<strong><em>推荐使用Rlock()</em></strong></p>
<p><strong>实例方法：</strong> 　　acquire([timeout]): 尝试获得锁定。使线程进入同步阻塞状态。<br>　　release(): 释放锁。使用前线程必须已获得锁定，否则将抛出异常</p>
</blockquote>
<h5 id="4-1-实例"><a href="#4-1-实例" class="headerlink" title="4.1 实例"></a>4.1 实例</h5><p>我的想法是新建一个共享文件tets.txt 其中已经写入一行 “a”, 现在实现用多线程访问该文件，每访问一次，在原来的基础上加 “a”。</p>
<ul>
<li><p>不加锁代码块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"test.txt"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(s)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"test.txt"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        line = f.readline()</span><br><span class="line">        print(<span class="string">"before : &#123;:&gt;10&#125;  ThreadName: &#123;:^&#125;"</span>.format(line, threading.current_thread().name))</span><br><span class="line">    save(line + <span class="string">"a"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    T = threading.Thread(target=read)</span><br><span class="line">    T.start()</span><br></pre></td></tr></table></figure>
</li>
<li><p>console: 可见并没有如我想象的输出 “a” “aa” “aaa”这样的，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">before :          a  ThreadName: Thread-2</span><br><span class="line">before :          a  ThreadName: Thread-1</span><br><span class="line">before :         aa  ThreadName: Thread-7</span><br><span class="line">before :         aa  ThreadName: Thread-8</span><br><span class="line">before :         aa  ThreadName: Thread-9</span><br><span class="line">before :             ThreadName: Thread-4</span><br><span class="line">before :             ThreadName: Thread-3</span><br><span class="line">before :             ThreadName: Thread-6</span><br><span class="line">before :             ThreadName: Thread-10</span><br><span class="line">before :             ThreadName: Thread-5</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>加锁代码块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"test.txt"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(s)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(lock)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"test.txt"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        line = f.readline()</span><br><span class="line">        print(<span class="string">"before : &#123;:&gt;10&#125;  ThreadName: &#123;:^&#125;"</span>.format(line, threading.current_thread().name))</span><br><span class="line">    save(line + <span class="string">"a"</span>)</span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line">loc = threading.RLock()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    T = threading.Thread(target=read, args=(loc, ))</span><br><span class="line">    T.start()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>console: 实现了预期的功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">before :          a  ThreadName: Thread-1</span><br><span class="line">before :         aa  ThreadName: Thread-9</span><br><span class="line">before :        aaa  ThreadName: Thread-2</span><br><span class="line">before :       aaaa  ThreadName: Thread-5</span><br><span class="line">before :      aaaaa  ThreadName: Thread-3</span><br><span class="line">before :     aaaaaa  ThreadName: Thread-4</span><br><span class="line">before :    aaaaaaa  ThreadName: Thread-8</span><br><span class="line">before :   aaaaaaaa  ThreadName: Thread-10</span><br><span class="line">before :  aaaaaaaaa  ThreadName: Thread-6</span><br><span class="line">before : aaaaaaaaaa  ThreadName: Thread-7</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>Lock和RLock的对比</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">lock = threading.Lock() <span class="comment">#Lock对象</span></span><br><span class="line">lock.acquire()</span><br><span class="line">lock.acquire()  <span class="comment">#产生了死锁。</span></span><br><span class="line">lock.release()</span><br><span class="line">lock.release()</span><br><span class="line"><span class="keyword">print</span> lock.acquire()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">rLock = threading.RLock()  <span class="comment">#RLock对象</span></span><br><span class="line">rLock.acquire()</span><br><span class="line">rLock.acquire() <span class="comment">#在同一线程内，程序不会堵塞。</span></span><br><span class="line">rLock.release()</span><br><span class="line">rLock.release()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="4-2-Condition"><a href="#4-2-Condition" class="headerlink" title="4.2 Condition"></a>4.2 Condition</h5><blockquote>
<p>Condition（条件变量）通常与一个锁关联。需要在多个Contidion中共享一个锁时，可以传递一个Lock/RLock实例给构造方法，否则它将自己生成一个RLock实例。</p>
<p>　　可以认为，除了Lock带有的锁定池外，Condition还包含一个等待池，池中的线程处于等待阻塞状态，直到另一个线程调用notify()/notifyAll()通知；得到通知后线程进入锁定池等待锁定。</p>
<p><strong>构造方法：</strong> Condition([lock/rlock])</p>
<p><strong>实例方法：</strong> 　　acquire([timeout])/release(): 调用关联的锁的相应方法。<br>　　wait([timeout]): 调用这个方法将使线程进入Condition的等待池等待通知，并释放锁。使用前线程必须已获得锁定，否则将抛出异常。<br>　　notify(): 调用这个方法将从等待池挑选一个线程并通知，收到通知的线程将自动调用acquire()尝试获得锁定（进入锁定池）；其他线程仍然在等待池中。调用这个方法不会释放锁定。使用前线程必须已获得锁定，否则将抛出异常。<br>　　notifyAll(): 调用这个方法将通知等待池中所有的线程，这些线程都将进入锁定池尝试获得锁定。调用这个方法不会释放锁定。使用前线程必须已获得锁定，否则将抛出异常</p>
</blockquote>
<h4 id="5-Event"><a href="#5-Event" class="headerlink" title="5.Event"></a>5.Event</h4><blockquote>
<p>Event（事件）是最简单的线程通信机制之一：一个线程通知事件，其他线程等待事件。Event内置了一个初始为False的标志，当调用set()时设为True，调用clear()时重置为 False。wait()将阻塞线程至等待阻塞状态。</p>
<p>　　Event其实就是一个简化版的 Condition。Event没有锁，无法使线程进入同步阻塞状态。</p>
<p><strong>构造方法：</strong> Event()</p>
<p><strong>实例方法：</strong> 　　isSet(): 当内置标志为True时返回True。<br>　　set(): 将标志设为True，并通知所有处于等待阻塞状态的线程恢复运行状态。<br>　　clear(): 将标志设为False。<br>　　wait([timeout]): 如果标志为True将立即返回，否则阻塞线程至等待阻塞状态，等待其他线程调用set()。</p>
</blockquote>
<p><em>跟多进程类似</em></p>
<ul>
<li><p>代码块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">event = threading.Event()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"输出第一部分，等待子线程设置event为True, event Status: &#123;&#125;"</span>.format(str(event.isSet())))</span><br><span class="line">    event.wait(<span class="number">2</span>) <span class="comment"># 阻塞 如果wait()里面设置了时间，那么等时间到，event也会被设置为True ,就看与.set()相比谁先</span></span><br><span class="line">    print(<span class="string">"等待时间已经到，重置为False"</span>)</span><br><span class="line">    event.clear()</span><br><span class="line">    print(<span class="string">"子线程将event设置为False，等待主线程置True，event Status: &#123;&#125;"</span>.format(str(event.is_set())))</span><br><span class="line">    event.wait()</span><br><span class="line">    print(<span class="string">"主进程已经将event设置为True, event Status: &#123;&#125;"</span>.format(str(event.isSet())))</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=func)</span><br><span class="line">t1.start()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"准备将even设置为True"</span>)</span><br><span class="line">time.sleep(<span class="number">4</span>)</span><br><span class="line">event.set()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>console:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输出第一部分，等待子线程设置event为True, event Status: False</span><br><span class="line">准备将even设置为True</span><br><span class="line">等待时间已经到，重置为False  #两秒后</span><br><span class="line">子线程将event设置为False，等待主线程置True，event Status: False</span><br><span class="line">主进程已经将event设置为True, event Status: True # 又过了两秒</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="6-timer"><a href="#6-timer" class="headerlink" title="6.timer"></a>6.timer</h4><blockquote>
<p>　Timer（定时器）是Thread的派生类，用于在指定时间后调用一个方法。</p>
<p><strong>构造方法：</strong> Timer(interval, function, args=[], kwargs={})<br>　　interval: 指定的时间<br>　　function: 要执行的方法<br>　　args/kwargs: 方法的参数</p>
<p><strong>实例方法：</strong> Timer从Thread派生，没有增加实例方法。</p>
</blockquote>
<ul>
<li><p>代码块：注意 <strong>type hint</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2019/4/7 22:33</span></span><br><span class="line"><span class="comment"># @Author  : YuChou</span></span><br><span class="line"><span class="comment"># @Site    :</span></span><br><span class="line"><span class="comment"># @File    : _thread.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(*args: tuple, **kwargs: dict)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    print(<span class="string">"args: &#123;&#125;, kwargs: &#123;&#125;"</span>.format(args, kwargs))</span><br><span class="line"></span><br><span class="line">t = threading.Timer(<span class="number">3</span>, f, args=(<span class="string">"a"</span>, <span class="number">1</span>), kwargs=&#123;<span class="string">'c'</span>: <span class="number">2</span>, <span class="string">'d'</span>: <span class="number">3</span>&#125;)</span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure>
<p>console：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">args: (&apos;a&apos;, 1), kwargs: &#123;&apos;c&apos;: 2, &apos;d&apos;: 3&#125;</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="7-local"><a href="#7-local" class="headerlink" title="7.local"></a>7.local</h4><blockquote>
<p>　　local是一个小写字母开头的类，用于管理 thread-local（线程局部的）数据。对于同一个local，线程无法访问其他线程设置的属性；线程设置的属性不会被其他线程设置的同名属性替换。</p>
<p>　　可以把local看成是一个“线程-属性字典”的字典，local封装了从自身使用线程作为 key检索对应的属性字典、再使用属性名作为key检索属性值的细节</p>
</blockquote>
<ul>
<li><p>代码块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">local = threading.local()</span><br><span class="line">local.tname = <span class="string">'Hello'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    local.tname = <span class="string">'World'</span></span><br><span class="line">    print(local.tname, end=<span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=func)</span><br><span class="line">t1.start()</span><br><span class="line">t1.join()</span><br><span class="line"></span><br><span class="line">print(local.tname)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>console：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">World Hello</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<hr>
<p>参考：<a href="https://www.cnblogs.com/tkqasn/p/5700281.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/tkqasn/p/5700281.html" target="_blank" rel="noopener">https://www.cnblogs.com/tkqasn/p/5700281.html</a></a></p>
<p>​    <a href="https://www.cnblogs.com/bingabcd/p/6671368.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/bingabcd/p/6671368.html" target="_blank" rel="noopener">https://www.cnblogs.com/bingabcd/p/6671368.html</a></a></p>
<p>​    <a href="https://www.python.org/dev/peps/pep-0484/" target="_blank" rel="noopener"><a href="https://www.python.org/dev/peps/pep-0484/" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0484/</a></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/05/Python多线程/" data-id="cju9u14tq0004uohzo5noc60b" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-Python多进程" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/31/Python多进程/" class="article-date">
  <time class="post-time" datetime="2019-03-31T03:03:50.000Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">31</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/31/Python多进程/">Python多进程</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Python多进程使用与总结"><a href="#Python多进程使用与总结" class="headerlink" title="Python多进程使用与总结"></a>Python多进程使用与总结</h2><h4 id="1-概要"><a href="#1-概要" class="headerlink" title="1.概要"></a>1.概要</h4><p>​    众所周知，由于GIL锁的存在，Python多线程并不是真正意义上的多线程，不能很好的利用多核CPU，为了充分的利用系统资源，py提供了multiprocessing多进程库，其支持子进程、通信和数据共享、执行不同形式的同步，提供了Process、Queue、Pipe、Lock等组件。[参考]（<a href="https://www.cnblogs.com/tkqasn/p/5701230.html" target="_blank" rel="noopener">https://www.cnblogs.com/tkqasn/p/5701230.html</a>）</p>
<blockquote>
<ul>
<li>在UNIX平台上，当某个进程终结之后，该进程需要被其父进程调用wait，否则进程成为僵尸进程(Zombie)。所以，有必要对每个Process对象调用join()方法 (实际上等同于wait)。对于多线程来说，由于只有一个进程，所以不存在此必要性。</li>
<li>multiprocessing提供了threading包中没有的IPC(比如Pipe和Queue)，效率上更高。应优先考虑Pipe和Queue，避免使用Lock/Event/Semaphore/Condition等同步方式 (因为它们占据的不是用户进程的资源)。</li>
<li>多进程应该避免共享资源。在多线程中，我们可以比较容易地共享资源，比如使用全局变量或者传递参数。在多进程情况下，由于每个进程有自己独立的内存空间，以上方法并不合适。此时我们可以通过共享内存和Manager的方法来共享资源。但这样做提高了程序的复杂度，并因为同步的需要而降低了程序的效率。</li>
<li>Process.PID中保存有PID，如果进程还没有start()，则PID为None。</li>
</ul>
</blockquote>
<p><strong><em>注意：window下启动子进程必须在if <strong>name</strong> == “main”语句后面写相关语句，这个坑踩过</em></strong></p>
<p><strong><em>注意：window下启动子进程必须在if name == “main”语句后面写相关语句，这个坑踩过</em></strong></p>
<h4 id="2-使用实例"><a href="#2-使用实例" class="headerlink" title="2.使用实例"></a>2.使用实例</h4><h5 id="2-1-创建多进程"><a href="#2-1-创建多进程" class="headerlink" title="2.1 创建多进程"></a>2.1 创建多进程</h5><h4 id="方式一：直接使用Process"><a href="#方式一：直接使用Process" class="headerlink" title="方式一：直接使用Process"></a>方式一：直接使用Process</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">out</span><span class="params">(msg)</span>:</span></span><br><span class="line">    s = random.randint(<span class="number">1</span>, <span class="number">3</span>) <span class="comment">#随机延时</span></span><br><span class="line">    time.sleep(s)</span><br><span class="line">    print(<span class="string">"msg:&#123;&#125;  time:&#123;&#125;   pid：&#123;&#125; ppid:&#123;&#125;"</span>.format(msg, time.asctime(time.localtime(time.time())), os.getpid(), os.getppid()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">que</span><span class="params">()</span>:</span></span><br><span class="line">    Queue = queue.Queue()<span class="comment">#创建队列 先进先出</span></span><br><span class="line">    <span class="keyword">for</span> q <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        Queue.put(q)</span><br><span class="line">    <span class="keyword">return</span> Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    Que = que()	</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p = multiprocessing.Process(target=out, args=(Que.get(), ))</span><br><span class="line">        p.start()</span><br><span class="line">        <span class="comment"># p.join() # location1</span></span><br><span class="line">    <span class="comment"># p.join() #location2</span></span><br><span class="line">    print(<span class="string">"我是主进程"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>基本逻辑：创建一个动作函数out() ,增加随机时间的延时，以便查看控制台输出差异，输出msg、当前时间、子进程pid、父进程pid。定义一个队列函数que(),作为生产者，为后面取得输出参数做好准备。p:创建一个进程，p.start()开启一个进程，p.join()阻塞主进程，直到子进程执行完毕.注意：<strong><em>window下启动子进程必须在if name == “main”语句后面写相关语句，这个坑踩过</em></strong>（不知道为什么这个markdown编辑器，双下滑线没有显示，可能是渲染引擎问题），args参数是元组类型，若是只有一个参数，需要加上最后 <code>，</code></p>
</li>
<li><p>location1处和location2处join均注释，主进程在子进程之前执行完毕，控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">我是主进程</span><br><span class="line">msg:2  time:Sun Mar 31 20:45:22 2019   pid：17068 ppid:28044</span><br><span class="line">msg:4  time:Sun Mar 31 20:45:22 2019   pid：25004 ppid:28044</span><br><span class="line">msg:5  time:Sun Mar 31 20:45:22 2019   pid：14576 ppid:28044</span><br><span class="line">msg:7  time:Sun Mar 31 20:45:23 2019   pid：26384 ppid:28044</span><br><span class="line">msg:9  time:Sun Mar 31 20:45:23 2019   pid：3368 ppid:28044</span><br><span class="line">msg:1  time:Sun Mar 31 20:45:23 2019   pid：25052 ppid:28044</span><br><span class="line">msg:3  time:Sun Mar 31 20:45:23 2019   pid：23948 ppid:28044</span><br><span class="line">msg:0  time:Sun Mar 31 20:45:24 2019   pid：13660 ppid:28044</span><br><span class="line">msg:6  time:Sun Mar 31 20:45:24 2019   pid：1052 ppid:28044</span><br><span class="line">msg:8  time:Sun Mar 31 20:45:25 2019   pid：13968 ppid:28044</span><br></pre></td></tr></table></figure>
</li>
<li><p>只有location2处join注释，主进程在子进程之后执行，但是可看出输出顺序是0~9，总的时间特别长，阻塞输出，控制台输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">msg:0  time:Sun Mar 31 20:51:06 2019   pid：11048 ppid:3936</span><br><span class="line">msg:1  time:Sun Mar 31 20:51:09 2019   pid：18504 ppid:3936</span><br><span class="line">msg:2  time:Sun Mar 31 20:51:10 2019   pid：15580 ppid:3936</span><br><span class="line">msg:3  time:Sun Mar 31 20:51:12 2019   pid：25180 ppid:3936</span><br><span class="line">msg:4  time:Sun Mar 31 20:51:15 2019   pid：25912 ppid:3936</span><br><span class="line">msg:5  time:Sun Mar 31 20:51:17 2019   pid：22660 ppid:3936</span><br><span class="line">msg:6  time:Sun Mar 31 20:51:21 2019   pid：13224 ppid:3936</span><br><span class="line">msg:7  time:Sun Mar 31 20:51:23 2019   pid：14204 ppid:3936</span><br><span class="line">msg:8  time:Sun Mar 31 20:51:24 2019   pid：2940 ppid:3936</span><br><span class="line">msg:9  time:Sun Mar 31 20:51:28 2019   pid：9068 ppid:3936</span><br><span class="line">我是主进程</span><br></pre></td></tr></table></figure>
</li>
<li><p>只有location1处join注释，主进程在子进程之后执行，其中很多进程执行时间相同，而且顺序错乱，总时间短，控制台输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">msg:1  time:Sun Mar 31 20:52:04 2019   pid：24448 ppid:13532</span><br><span class="line">msg:5  time:Sun Mar 31 20:52:04 2019   pid：23376 ppid:13532</span><br><span class="line">msg:2  time:Sun Mar 31 20:52:05 2019   pid：22048 ppid:13532</span><br><span class="line">msg:6  time:Sun Mar 31 20:52:05 2019   pid：18968 ppid:13532</span><br><span class="line">msg:7  time:Sun Mar 31 20:52:05 2019   pid：26208 ppid:13532</span><br><span class="line">msg:0  time:Sun Mar 31 20:52:06 2019   pid：15948 ppid:13532</span><br><span class="line">msg:3  time:Sun Mar 31 20:52:06 2019   pid：26724 ppid:13532</span><br><span class="line">msg:4  time:Sun Mar 31 20:52:06 2019   pid：13220 ppid:13532</span><br><span class="line">msg:8  time:Sun Mar 31 20:52:06 2019   pid：24384 ppid:13532</span><br><span class="line">msg:9  time:Sun Mar 31 20:52:06 2019   pid：4392 ppid:13532</span><br><span class="line">我是主进程</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="方式二：重写run-方法"><a href="#方式二：重写run-方法" class="headerlink" title="方式二：重写run()方法"></a>方式二：重写run()方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myprocess</span><span class="params">(Process)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        super(Myprocess, self).__init__()<span class="comment"># 或者Process.__init__(self)</span></span><br><span class="line">        self.msg = msg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        s = random.randint(<span class="number">1</span>, <span class="number">3</span>)  <span class="comment"># 随机延时</span></span><br><span class="line">        time.sleep(s)</span><br><span class="line">        print(<span class="string">"msg:&#123;&#125;  time:&#123;&#125;   pid：&#123;&#125; ppid:&#123;&#125;"</span>.format(self.msg, time.asctime(time.localtime(time.time())), os.getpid(),</span><br><span class="line">                                                        os.getppid()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">que</span><span class="params">()</span>:</span></span><br><span class="line">    Queue = queue.Queue()  <span class="comment"># 创建队列 先进先出</span></span><br><span class="line">    <span class="keyword">for</span> q <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        Queue.put(q)</span><br><span class="line">    <span class="keyword">return</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    Que = que()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p = Myprocess(msg=Que.get())</span><br><span class="line">        p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">"我是主进程"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>基本逻辑：定义一个子类，继承Process类，因为不想完全重写父类的<strong>init</strong>，所以这里使用super()或者Process.<strong>init</strong>(self)将子类参数传递给父类。其中run()方法为动作函数，这个也是来自父类的方法，这里因为准备完全重写父类的方法，所以不用super()方法，也可以使用super(Myprocess, self).run()来避免完全重写父类方法。函数功能run()对应前面的out()函数功能。</p>
</li>
<li><blockquote>
<p><strong>super()</strong> 函数是用于调用父类(超类)的一个方法。super 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题。MRO 就是类的方法解析顺序表, 其实也就是继承父类方法时的顺序表</p>
</blockquote>
</li>
<li><p>没弄明白为什么这个主进程没有阻塞，控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">msg:2  time:Sun Mar 31 21:40:37 2019   pid：4396 ppid:23176</span><br><span class="line">msg:3  time:Sun Mar 31 21:40:37 2019   pid：18640 ppid:23176</span><br><span class="line">msg:8  time:Sun Mar 31 21:40:37 2019   pid：13612 ppid:23176</span><br><span class="line">msg:9  time:Sun Mar 31 21:40:37 2019   pid：13196 ppid:23176</span><br><span class="line">我是主进程</span><br><span class="line">msg:1  time:Sun Mar 31 21:40:38 2019   pid：16324 ppid:23176</span><br><span class="line">msg:4  time:Sun Mar 31 21:40:38 2019   pid：14560 ppid:23176</span><br><span class="line">msg:5  time:Sun Mar 31 21:40:38 2019   pid：6376 ppid:23176</span><br><span class="line">msg:6  time:Sun Mar 31 21:40:38 2019   pid：26088 ppid:23176</span><br><span class="line">msg:7  time:Sun Mar 31 21:40:38 2019   pid：23056 ppid:23176</span><br><span class="line">msg:0  time:Sun Mar 31 21:40:39 2019   pid：14724 ppid:23176</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="2-2-Process类"><a href="#2-2-Process类" class="headerlink" title="2.2 Process类"></a>2.2 Process类</h5><hr>
<blockquote>
<ul>
<li><p><strong>构造方法：</strong></p>
<p>Process([group [, target [, name [, args [, kwargs]]]]])</p>
<p>　　group: 线程组，目前还没有实现，库引用中提示必须是None；<br>　　target: 要执行的方法；<br>　　name: 进程名；<br>　　args/kwargs: 要传入方法的参数。。</p>
</li>
<li><p><strong>实例方法：</strong></p>
<p>　　is_alive()：返回进程是否在运行。</p>
<p>　　join([timeout])：阻塞当前上下文环境的进程程，直到调用此方法的进程终止或到达指定的timeout（可选参数）。</p>
<p>　　start()：进程准备就绪，等待CPU调度</p>
<p>　　run()：strat()调用run方法，如果实例进程时未制定传入target，这star执行t默认run()方法。</p>
<p>　　terminate()：不管任务是否完成，立即停止工作进程，但是子进程如果存在没完成，就会变成僵尸进程</p>
</li>
<li><p><strong>属性：</strong></p>
<p>　　authkey</p>
<p>　　daemon：和线程的setDeamon功能一样，守护进程，父进程死了子进程也死了</p>
<p>　　exitcode(进程在运行时为None、如果为–N，表示被信号N结束）</p>
<p>　　name：进程名字。</p>
<p>　　pid：进程号。</p>
</li>
</ul>
</blockquote>
<ul>
<li>is_alive()、p.name、p.pid 、p.exitcode:实例：下面代码用的是重写的Myprocess，直接使用Process也是一样的</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">..........</span><br><span class="line">p = Myprocess(msg=<span class="number">10086</span>)</span><br><span class="line">p.start()</span><br><span class="line">print(<span class="string">"is_alive() :&#123;&#125;"</span>.format(p.is_alive()))</span><br><span class="line">print(<span class="string">"p.exitcode: &#123;&#125;"</span>.format(p.exitcode))</span><br><span class="line">p.join()</span><br><span class="line">print(<span class="string">"is_alive() :&#123;&#125;"</span>.format(p.is_alive()))</span><br><span class="line">print(<span class="string">"p.exitcode: &#123;&#125;"</span>.format(p.exitcode))</span><br><span class="line">print(<span class="string">"p.name :&#123;&#125;"</span>.format(p.name))</span><br><span class="line">print(<span class="string">"p.pid :&#123;&#125;"</span>.format(p.pid))</span><br><span class="line">print(<span class="string">"我是主进程"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">is_alive() :True</span><br><span class="line">p.exitcode: None</span><br><span class="line">msg:10086  time:Sun Mar 31 22:04:38 2019   pid：22796 ppid:10980</span><br><span class="line">is_alive() :False</span><br><span class="line">p.exitcode: 0</span><br><span class="line">p.name :Myprocess-1</span><br><span class="line">p.pid :22796</span><br><span class="line">我是主进程</span><br></pre></td></tr></table></figure>
</li>
<li><p>setDaemon()方法。主进程A中，创建了子进程B，并且在主进程A中调用了B.setDaemon()，这个的意思是，把主进程A设置为守护进程，这时候，要是主进程A执行结束了，就不管子进程B是否完成，一并和进程程A退出.这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，默认False</p>
</li>
<li><p>代码，例1：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.......</span><br><span class="line">p = Myprocess(msg=<span class="number">10086</span>)</span><br><span class="line">p.daemon = <span class="keyword">True</span></span><br><span class="line">p.start()</span><br><span class="line"><span class="comment"># p.join()</span></span><br><span class="line">print(<span class="string">"我是主进程"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>输出1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我是主进程</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>代码，例2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">........</span><br><span class="line">p = Myprocess(msg=<span class="number">10086</span>)</span><br><span class="line"> <span class="comment"># p.daemon = True</span></span><br><span class="line"> p.start()</span><br><span class="line"> <span class="comment"># p.join()</span></span><br><span class="line"> print(<span class="string">"我是主进程"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>输出2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我是主进程</span><br><span class="line">msg:10086  time:Sun Mar 31 22:21:34 2019   pid：6788 ppid:556</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="2-3-Pool类"><a href="#2-3-Pool类" class="headerlink" title="2.3 Pool类"></a>2.3 Pool类</h5><blockquote>
<p>进程池内部维护一个进程序列，当使用时，则去进程池中获取一个进程，如果进程池序列中没有可供使用的进进程，那么程序就会等待，直到进程池中有可用进程为止。进程池设置最好等于CPU核心数量</p>
<p><strong>构造方法：</strong></p>
<p>Pool([processes[, initializer[, initargs[, maxtasksperchild[, context]]]]])</p>
<p><strong>processes</strong> ：使用的工作进程的数量，如果processes是None那么使用 os.cpu_count()返回的数量。<br><strong>initializer：</strong> 如果initializer是None，那么每一个工作进程在开始的时候会调用initializer(*initargs)。<br><strong>maxtasksperchild：</strong>工作进程退出之前可以完成的任务数，完成后用一个新的工作进程来替代原进程，来让闲置的资源被释放。maxtasksperchild默认是None，意味着只要Pool存在工作进程就会一直存活。<br><strong>context:</strong> 用在制定工作进程启动时的上下文，一般使用 multiprocessing.Pool() 或者一个context对象的Pool()方法来创建一个池，两种方法都适当的设置了context</p>
<p><strong>实例方法：</strong></p>
<p>　　<strong>apply(func[, args[, kwds]])：同步进程池</strong></p>
<p>　　<strong>apply_async(func[, args[, kwds[, callback[, error_callback]]]]) ：异步进程池</strong></p>
<p>　　close() ： 关闭进程池，阻止更多的任务提交到pool，待任务完成后，工作进程会退出。</p>
<p>　　terminate() ： 结束工作进程，不在处理未完成的任务</p>
<p>　　join() : wait工作线程的退出，在调用join()前，必须调用close() or terminate()。这样是因为被终止的进程需要被父进程调用wait（join等价与wait），否则进程会成为僵尸进程。pool.join()必须使用在</p>
</blockquote>
<ul>
<li><p>进程池异步：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">out</span><span class="params">(msg)</span>:</span></span><br><span class="line">    s = random.randint(<span class="number">1</span>, <span class="number">3</span>) <span class="comment">#随机延时</span></span><br><span class="line">    time.sleep(s)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"msg:&#123;&#125;  time:&#123;&#125;   pid：&#123;&#125; ppid:&#123;&#125;"</span>.format(msg, time.asctime(time.localtime(time.time())), os.getpid(), os.getppid())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(arg)</span>:</span></span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">que</span><span class="params">()</span>:</span></span><br><span class="line">    Queue = queue.Queue()<span class="comment">#创建队列 先进先出</span></span><br><span class="line">    <span class="keyword">for</span> q <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        Queue.put(q)</span><br><span class="line">    <span class="keyword">return</span> Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    Que = que()</span><br><span class="line">    pool = multiprocessing.Pool(processes=multiprocessing.cpu_count())<span class="comment">#取最大CPU数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        pool.apply_async(func=out, args=(Que.get(),), callback=callback) <span class="comment">#callback自动接收func返回来的内容</span></span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()  <span class="comment"># 进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭</span></span><br><span class="line">    print(<span class="string">"我是主进程"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>控制台输出：总时间短，且执行顺序乱，非阻塞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">msg:2  time:Sun Mar 31 22:35:44 2019   pid：23020 ppid:16652</span><br><span class="line">msg:3  time:Sun Mar 31 22:35:44 2019   pid：26476 ppid:16652</span><br><span class="line">msg:6  time:Sun Mar 31 22:35:44 2019   pid：26204 ppid:16652</span><br><span class="line">msg:7  time:Sun Mar 31 22:35:44 2019   pid：17256 ppid:16652</span><br><span class="line">msg:0  time:Sun Mar 31 22:35:45 2019   pid：26980 ppid:16652</span><br><span class="line">msg:4  time:Sun Mar 31 22:35:45 2019   pid：10248 ppid:16652</span><br><span class="line">msg:1  time:Sun Mar 31 22:35:46 2019   pid：23180 ppid:16652</span><br><span class="line">msg:5  time:Sun Mar 31 22:35:46 2019   pid：22796 ppid:16652</span><br><span class="line">msg:8  time:Sun Mar 31 22:35:47 2019   pid：23020 ppid:16652</span><br><span class="line">msg:9  time:Sun Mar 31 22:35:47 2019   pid：26476 ppid:16652</span><br><span class="line">我是主进程</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>进程池同步：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">out</span><span class="params">(msg)</span>:</span></span><br><span class="line">    s = random.randint(<span class="number">1</span>, <span class="number">3</span>) <span class="comment">#随机延时</span></span><br><span class="line">    time.sleep(s)</span><br><span class="line">    print(<span class="string">"msg:&#123;&#125;  time:&#123;&#125;   pid：&#123;&#125; ppid:&#123;&#125;"</span>.format(msg, time.asctime(time.localtime(time.time())), os.getpid(), os.getppid()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">que</span><span class="params">()</span>:</span></span><br><span class="line">    Queue = queue.Queue()<span class="comment">#创建队列 先进先出</span></span><br><span class="line">    <span class="keyword">for</span> q <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        Queue.put(q)</span><br><span class="line">    <span class="keyword">return</span> Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    Que = que()</span><br><span class="line">    pool = multiprocessing.Pool(processes=multiprocessing.cpu_count())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        pool.apply(func=out, args=(Que.get(),)) <span class="comment">#callback自动接收func返回来的内容</span></span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()  <span class="comment"># 进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭</span></span><br><span class="line">    print(<span class="string">"我是主进程"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>控制台输出：总时间长，顺序执行，阻塞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">msg:0  time:Sun Mar 31 22:40:36 2019   pid：24072 ppid:13240</span><br><span class="line">msg:1  time:Sun Mar 31 22:40:37 2019   pid：13552 ppid:13240</span><br><span class="line">msg:2  time:Sun Mar 31 22:40:40 2019   pid：13736 ppid:13240</span><br><span class="line">msg:3  time:Sun Mar 31 22:40:43 2019   pid：8040 ppid:13240</span><br><span class="line">msg:4  time:Sun Mar 31 22:40:46 2019   pid：12532 ppid:13240</span><br><span class="line">msg:5  time:Sun Mar 31 22:40:48 2019   pid：24272 ppid:13240</span><br><span class="line">msg:6  time:Sun Mar 31 22:40:49 2019   pid：14028 ppid:13240</span><br><span class="line">msg:7  time:Sun Mar 31 22:40:52 2019   pid：22340 ppid:13240</span><br><span class="line">msg:8  time:Sun Mar 31 22:40:55 2019   pid：24072 ppid:13240</span><br><span class="line">msg:9  time:Sun Mar 31 22:40:56 2019   pid：13552 ppid:13240</span><br><span class="line">我是主进程</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>如果动作函数是带返回值的不仅可以使用callback输出还可以使用get()方法</p>
</li>
<li><p>错误的get使用方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">out</span><span class="params">(msg)</span>:</span></span><br><span class="line">    s = random.randint(<span class="number">1</span>, <span class="number">3</span>) <span class="comment">#随机延时</span></span><br><span class="line">    time.sleep(s)</span><br><span class="line">    print(<span class="string">"msg:&#123;&#125;  time:&#123;&#125;   pid：&#123;&#125; ppid:&#123;&#125;"</span>.format(msg, time.asctime(time.localtime(time.time())), os.getpid(), os.getppid()))</span><br><span class="line">    <span class="keyword">return</span> msg</span><br><span class="line">  ... ..... .........省略........</span><br><span class="line">    <span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    Que = que()</span><br><span class="line">    pool = multiprocessing.Pool(processes=multiprocessing.cpu_count())</span><br><span class="line">    l = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        r = pool.apply_async(func=out, args=(Que.get(),)) </span><br><span class="line">        print(r.get())</span><br><span class="line">        <span class="comment"># l.append(r)</span></span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()  <span class="comment"># 进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭</span></span><br><span class="line">    <span class="comment"># for i in l:</span></span><br><span class="line">    <span class="comment">#     print(i.get())</span></span><br><span class="line">    print(<span class="string">"我是主进程"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>控制台输出：顺讯执行，时间长，阻塞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">msg:0  time:Sun Mar 31 22:49:22 2019   pid：15668 ppid:13468</span><br><span class="line">0</span><br><span class="line">msg:1  time:Sun Mar 31 22:49:24 2019   pid：5968 ppid:13468</span><br><span class="line">1</span><br><span class="line">msg:2  time:Sun Mar 31 22:49:25 2019   pid：25524 ppid:13468</span><br><span class="line">2</span><br><span class="line">msg:3  time:Sun Mar 31 22:49:28 2019   pid：14148 ppid:13468</span><br><span class="line">3</span><br><span class="line">msg:4  time:Sun Mar 31 22:49:31 2019   pid：15240 ppid:13468</span><br><span class="line">4</span><br><span class="line">msg:5  time:Sun Mar 31 22:49:32 2019   pid：22544 ppid:13468</span><br><span class="line">5</span><br><span class="line">msg:6  time:Sun Mar 31 22:49:35 2019   pid：5364 ppid:13468</span><br><span class="line">6</span><br><span class="line">msg:7  time:Sun Mar 31 22:49:37 2019   pid：24740 ppid:13468</span><br><span class="line">7</span><br><span class="line">msg:8  time:Sun Mar 31 22:49:40 2019   pid：15668 ppid:13468</span><br><span class="line">8</span><br><span class="line">msg:9  time:Sun Mar 31 22:49:43 2019   pid：5968 ppid:13468</span><br><span class="line">9</span><br><span class="line">我是主进程</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>错误的get使用方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...........................</span><br><span class="line">    Que = que()</span><br><span class="line">    pool = multiprocessing.Pool(processes=multiprocessing.cpu_count())</span><br><span class="line">    l = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        r = pool.apply_async(func=out, args=(Que.get(),)) <span class="comment">#callback自动接收func返回来的内容</span></span><br><span class="line">        <span class="comment"># print(r.get())</span></span><br><span class="line">        l.append(r)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()  <span class="comment"># 进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">        print(i.get())</span><br><span class="line">    print(<span class="string">"我是主进程"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>控制台输出：顺序错乱，总时间短，非阻塞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">msg:6  time:Sun Mar 31 22:53:28 2019   pid：8600 ppid:25532</span><br><span class="line">msg:1  time:Sun Mar 31 22:53:29 2019   pid：5960 ppid:25532</span><br><span class="line">msg:0  time:Sun Mar 31 22:53:29 2019   pid：24544 ppid:25532</span><br><span class="line">msg:3  time:Sun Mar 31 22:53:29 2019   pid：15672 ppid:25532</span><br><span class="line">msg:4  time:Sun Mar 31 22:53:29 2019   pid：21808 ppid:25532</span><br><span class="line">msg:8  time:Sun Mar 31 22:53:29 2019   pid：8600 ppid:25532</span><br><span class="line">msg:7  time:Sun Mar 31 22:53:29 2019   pid：19028 ppid:25532</span><br><span class="line">msg:2  time:Sun Mar 31 22:53:30 2019   pid：9820 ppid:25532</span><br><span class="line">msg:5  time:Sun Mar 31 22:53:30 2019   pid：12736 ppid:25532</span><br><span class="line">msg:9  time:Sun Mar 31 22:53:32 2019   pid：24544 ppid:25532</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">我是主进程</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="2-4-数据共享"><a href="#2-4-数据共享" class="headerlink" title="2.4 数据共享"></a>2.4 数据共享</h5><blockquote>
<p>进程各自持有一份数据，默认无法共享数据</p>
</blockquote>
<ul>
<li><p>Array()实现：</p>
<ul>
<li>C语言参数类型对照</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">‘c’: ctypes.c_char　 ‘u’: ctypes.c_wchar　　‘b’: ctypes.c_byte　　　 ‘B’: ctypes.c_ubyte</span><br><span class="line">‘h’: ctypes.c_short　‘H’: ctypes.c_ushort　‘i’: ctypes.c_int　　　　　‘I’: ctypes.c_uint</span><br><span class="line">‘l’: ctypes.c_long,　‘L’: ctypes.c_ulong　　‘f’: ctypes.c_float　　‘d’: ctypes.c_double</span><br></pre></td></tr></table></figure>
<ul>
<li><p>代码块和输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Array</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a)</span>:</span></span><br><span class="line">    a[<span class="number">0</span>] = a[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = Array(<span class="string">'u'</span>, <span class="string">"Hello World"</span>)</span><br><span class="line">    p = Process(target=f, args=(arr,))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    print(arr[:])</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    -----控制台输出------</span><br><span class="line">    </span><br><span class="line">    dello World</span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Manager()实现：</p>
<blockquote>
<p>Manager()返回的manager提供list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Barrier, Queue, Value and Array类型的支持</p>
</blockquote>
</li>
<li><p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Manager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(d, l)</span>:</span></span><br><span class="line">    d[<span class="number">1</span>] = <span class="string">'1'</span></span><br><span class="line">    d[<span class="string">'2'</span>] = <span class="number">2</span></span><br><span class="line">    d[<span class="number">0.25</span>] = <span class="keyword">None</span></span><br><span class="line">    l.reverse()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    manager = Manager()</span><br><span class="line"></span><br><span class="line">    d = manager.dict()</span><br><span class="line">    l = manager.list(range(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">    p = Process(target=f, args=(d, l))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line">    print(d)</span><br><span class="line">    print(l)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;1: &apos;1&apos;, &apos;2&apos;: 2, 0.25: None&#125;</span><br><span class="line">[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="2-5-Lock互斥锁"><a href="#2-5-Lock互斥锁" class="headerlink" title="2.5 Lock互斥锁"></a>2.5 Lock互斥锁</h5><blockquote>
<p>当多个进程需要访问共享资源的时候，Lock可以用来避免访问的冲突</p>
</blockquote>
<blockquote>
<p><strong>进程之间数据隔离，但是共享一套文件系统，因而可以通过文件来实现进程直接的通信，但问题是必须自己加锁处理。</strong></p>
<p>注意：加锁的目的是为了保证多个进程修改同一块数据时，同一时间只能有一个修改，即串行的修改，没错，速度是慢了，牺牲了速度而保证了数据安全</p>
</blockquote>
<ul>
<li><p>代码实例，不加锁：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Lock</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(lock, i)</span>:</span></span><br><span class="line">    <span class="comment"># lock.acquire()</span></span><br><span class="line">    file(i)</span><br><span class="line">    read()</span><br><span class="line">    <span class="comment"># lock.release()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"test.txt"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"test.txt"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        line = f.readline()</span><br><span class="line">        print(<span class="string">"a: &#123;&#125; "</span>.format(line))</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    lock = Lock()</span><br><span class="line">    file(str(<span class="number">0</span>))</span><br><span class="line">    read()</span><br><span class="line">    <span class="keyword">for</span>  i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p = Process(target=write, args=(lock, str(i)))</span><br><span class="line">        p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">"我是主进程"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>控制台输出：可见有几次读到的都是0，表明某个时刻几个进程都同时去访问了该文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a: 0 </span><br><span class="line">a: 2 </span><br><span class="line">a: 0 </span><br><span class="line">a: 0 </span><br><span class="line">a: 3 </span><br><span class="line">a: 5 </span><br><span class="line">a: 4 </span><br><span class="line">a: 6 </span><br><span class="line">a: 7 </span><br><span class="line">a: 8 </span><br><span class="line">a: 9 </span><br><span class="line">我是主进程</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>代码实例，加锁：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">..........</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(lock, i)</span>:</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    file(i)</span><br><span class="line">    read()</span><br><span class="line">    lock.release()</span><br><span class="line">...........</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a: 0 </span><br><span class="line">a: 1 </span><br><span class="line">a: 0 </span><br><span class="line">a: 2 </span><br><span class="line">a: 3 </span><br><span class="line">a: 4 </span><br><span class="line">a: 6 </span><br><span class="line">a: 5 </span><br><span class="line">a: 7 </span><br><span class="line">a: 8 </span><br><span class="line">a: 9 </span><br><span class="line">我是主进程</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="2-6-Semaphore"><a href="#2-6-Semaphore" class="headerlink" title="2.6 Semaphore"></a>2.6 <strong>Semaphore</strong></h5><p>用来控制对共享资源的访问数量</p>
<ul>
<li><p>普通代码示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="comment"># s.acquire()</span></span><br><span class="line">    print(multiprocessing.current_process().name + <span class="string">"acquire"</span>)</span><br><span class="line">    time.sleep(i)</span><br><span class="line">    print(multiprocessing.current_process().name + <span class="string">"release\n"</span>)</span><br><span class="line">    <span class="comment"># s.release()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># s = multiprocessing.Semaphore(2)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p = multiprocessing.Process(target = worker, args=(i*<span class="number">2</span>, ))</span><br><span class="line">        p.start(）</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>控制台输出：观察换行，可以看出同一时段，会有很多进程都在访问这个worke函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Process-1acquire</span><br><span class="line">Process-2acquire</span><br><span class="line">Process-1release</span><br><span class="line"></span><br><span class="line">Process-3acquire</span><br><span class="line">Process-4acquire</span><br><span class="line">Process-5acquire</span><br><span class="line">Process-7acquire</span><br><span class="line">Process-6acquire</span><br><span class="line">Process-8acquire</span><br><span class="line">Process-9acquire</span><br><span class="line">Process-10acquire</span><br><span class="line">Process-2release</span><br><span class="line"></span><br><span class="line">Process-3release</span><br><span class="line"></span><br><span class="line">Process-4release</span><br><span class="line"></span><br><span class="line">Process-5release</span><br><span class="line"></span><br><span class="line">Process-6release</span><br><span class="line"></span><br><span class="line">Process-7release</span><br><span class="line"></span><br><span class="line">Process-8release</span><br><span class="line"></span><br><span class="line">Process-9release</span><br><span class="line"></span><br><span class="line">Process-10release</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>用Semaphore代码实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2019/3/31 10:42</span></span><br><span class="line"><span class="comment"># @Author  : YuChou</span></span><br><span class="line"><span class="comment"># @Site    : </span></span><br><span class="line"><span class="comment"># @File    : examp.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(i,s)</span>:</span></span><br><span class="line">    s.acquire()</span><br><span class="line">    print(multiprocessing.current_process().name + <span class="string">"acquire"</span>)</span><br><span class="line">    time.sleep(i)</span><br><span class="line">    print(multiprocessing.current_process().name + <span class="string">"release\n"</span>)</span><br><span class="line">    s.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    s = multiprocessing.Semaphore(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p = multiprocessing.Process(target = worker, args=(i*<span class="number">2</span>, s))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>控制台输出：观察换行，可以看出同时并存最多只有两个进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Process-3acquire</span><br><span class="line">Process-1acquire</span><br><span class="line">Process-1release</span><br><span class="line"></span><br><span class="line">Process-4acquire</span><br><span class="line">Process-3release</span><br><span class="line"></span><br><span class="line">Process-2acquire</span><br><span class="line">Process-2release</span><br><span class="line"></span><br><span class="line">Process-5acquire</span><br><span class="line">Process-4release</span><br><span class="line"></span><br><span class="line">Process-6acquire</span><br><span class="line">Process-5release</span><br><span class="line"></span><br><span class="line">Process-7acquire</span><br><span class="line">Process-6release</span><br><span class="line"></span><br><span class="line">Process-8acquire</span><br><span class="line">Process-7release</span><br><span class="line"></span><br><span class="line">Process-9acquire</span><br><span class="line">Process-8release</span><br><span class="line"></span><br><span class="line">Process-10acquire</span><br><span class="line">Process-9release</span><br><span class="line"></span><br><span class="line">Process-10release</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="2-7-Event"><a href="#2-7-Event" class="headerlink" title="2.7 Event"></a>2.7 Event</h5><blockquote>
<p>用于进程间通信，即程序中的其一个线程需要通过判断某个进程的状态来确定自己下一步的操作，就用到了event对象</p>
<p>event对象默认为假（Flase），即遇到event对象在等待就阻塞线程的执行</p>
<p>可以通过is_set()查看当前状态</p>
</blockquote>
<ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.wait()    #括号里可以带数字执行，数字表示等待的秒数，不带数字表示一直阻塞状态</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.set()     #默认为False，set一次表示True，所以子线程里的foo函数解除阻塞状态继续执行</span><br></pre></td></tr></table></figure>
</li>
<li><p>主进程和子进程之间的通信：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">child</span><span class="params">(even)</span>:</span></span><br><span class="line">    print(<span class="string">"start child....."</span>)</span><br><span class="line">    even.wait()</span><br><span class="line">    print(<span class="string">"end child....."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    </span><br><span class="line">    even = multiprocessing.Event()</span><br><span class="line">    p = multiprocessing.Process(target=child, args=(even,))</span><br><span class="line">    p.start()</span><br><span class="line">    print(<span class="string">"主进程等待...."</span>)</span><br><span class="line">    time.sleep(<span class="number">4</span>)</span><br><span class="line">    print(<span class="string">"主进程结束等待"</span>)</span><br><span class="line">    even.set()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>控制台输出：可以看出，子进程一直在等set</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主进程等待....</span><br><span class="line">start child.....</span><br><span class="line">主进程结束等待</span><br><span class="line">end child.....</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>给与wait值为2s</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">child</span><span class="params">(even, s)</span>:</span></span><br><span class="line">    print(<span class="string">"start child....."</span>)</span><br><span class="line">    even.wait(s)</span><br><span class="line">    print(<span class="string">"end child....."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    even = multiprocessing.Event()</span><br><span class="line">    p = multiprocessing.Process(target=child, args=(even,<span class="number">2</span>))</span><br><span class="line">    p.start()</span><br><span class="line">    print(<span class="string">"主进程等待...."</span>)</span><br><span class="line">    time.sleep(<span class="number">4</span>)</span><br><span class="line">    print(<span class="string">"主进程结束等待"</span>)</span><br><span class="line">    even.set()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>控制台输出：可见并没有等待set, 子进程已经解除阻塞了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主进程等待....</span><br><span class="line">start child.....</span><br><span class="line">end child.....</span><br><span class="line">主进程结束等待</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>当然也可以用在子进程与子进程之间，不详解</li>
</ul>
<h5 id="2-8-Queue"><a href="#2-8-Queue" class="headerlink" title="2.8 Queue"></a>2.8 Queue</h5><blockquote>
<p>Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。put方法用以插入数据到队列中，put方法还有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，该方法会阻塞timeout指定的时间，直到该队列有剩余的空间。如果超时，会抛出Queue.Full异常。如果blocked为False，但该Queue已满，会立即抛出Queue.Full异常。</p>
<p>get方法可以从队列读取并且删除一个元素。同样，get方法有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，那么在等待时间内没有取到任何元素，会抛出Queue.Empty异常。如果blocked为False，有两种情况存在，如果Queue有一个值可用，则立即返回该值，否则，如果队列为空，则立即抛出Queue.Empty异常。Queue的一段示例代码：</p>
</blockquote>
<ul>
<li><p>代码块：来源<a href="https://www.cnblogs.com/kaituorensheng/p/4445418.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/kaituorensheng/p/4445418.html" target="_blank" rel="noopener">https://www.cnblogs.com/kaituorensheng/p/4445418.html</a></a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer_proc</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        q.put(<span class="number">1</span>, block = <span class="keyword">False</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader_proc</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(q.get(block = <span class="keyword">False</span>))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    q = multiprocessing.Queue()</span><br><span class="line">    writer = multiprocessing.Process(target=writer_proc, args=(q,))</span><br><span class="line">    writer.start()</span><br><span class="line"></span><br><span class="line">    reader = multiprocessing.Process(target=reader_proc, args=(q,))</span><br><span class="line">    reader.start()</span><br><span class="line"></span><br><span class="line">    reader.join()</span><br><span class="line">    writer.join()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>控制台输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="2-9-Pipe"><a href="#2-9-Pipe" class="headerlink" title="2.9 Pipe"></a>2.9 Pipe</h5><blockquote>
<p>Pipe方法返回(conn1, conn2)代表一个管道的两个端。Pipe方法有duplex参数，如果duplex参数为True(默认值)，那么这个管道是全双工模式，也就是说conn1和conn2均可收发。duplex为False，conn1只负责接受消息，conn2只负责发送消息。</p>
<p>send和recv方法分别是发送和接受消息的方法。例如，在全双工模式下，可以调用conn1.send发送消息，conn1.recv接收消息。如果没有消息可接收，recv方法会一直阻塞。如果管道已经被关闭，那么recv方法会抛出EOFError。close方法表示关闭管道，当消息接收结束以后，关闭管道。</p>
</blockquote>
<ul>
<li><p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pro</span><span class="params">(p)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p.send(i)</span><br><span class="line">        print(<span class="string">"我发啦"</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cou</span><span class="params">(c)</span>:</span></span><br><span class="line">    n=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt;= <span class="number">9</span>:</span><br><span class="line">       print(c.recv())</span><br><span class="line">       print(<span class="string">"我收啦\n"</span>)</span><br><span class="line">       time.sleep(<span class="number">1</span>)</span><br><span class="line">       n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    p, c = multiprocessing.Pipe()</span><br><span class="line">    m1 = multiprocessing.Process(target=pro, args=(p,))</span><br><span class="line">    m2 = multiprocessing.Process(target=cou, args=(c,))</span><br><span class="line">    m1.start()</span><br><span class="line">    m2.start()</span><br><span class="line">    m1.join()</span><br><span class="line">    m2.join()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>控制台输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">我发啦</span><br><span class="line">0</span><br><span class="line">我收啦</span><br><span class="line"></span><br><span class="line">我发啦</span><br><span class="line">1</span><br><span class="line">我收啦</span><br><span class="line"></span><br><span class="line">我发啦</span><br><span class="line">2</span><br><span class="line">我收啦</span><br><span class="line"></span><br><span class="line">我发啦</span><br><span class="line">3</span><br><span class="line">我收啦</span><br><span class="line"></span><br><span class="line">我发啦</span><br><span class="line">4</span><br><span class="line">我收啦</span><br><span class="line"></span><br><span class="line">我发啦</span><br><span class="line">5</span><br><span class="line">我收啦</span><br><span class="line"></span><br><span class="line">我发啦</span><br><span class="line">6</span><br><span class="line">我收啦</span><br><span class="line"></span><br><span class="line">我发啦</span><br><span class="line">7</span><br><span class="line">我收啦</span><br><span class="line"></span><br><span class="line">我发啦</span><br><span class="line">8</span><br><span class="line">我收啦</span><br><span class="line"></span><br><span class="line">我发啦</span><br><span class="line">9</span><br><span class="line">我收啦</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="2-10-subprocess三方模块"><a href="#2-10-subprocess三方模块" class="headerlink" title="2.10 subprocess三方模块"></a>2.10 subprocess三方模块</h5><blockquote>
<p>很多时候，子进程并不是自身，而是一个外部进程。我们创建了子进程后，还需要控制子进程的输入和输出。</p>
<p><code>subprocess</code>模块可以让我们非常方便地启动一个子进程，然后控制其输入和输出。</p>
</blockquote>
<ul>
<li><p>代码块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">r = subprocess.call([<span class="string">"python"</span>, <span class="string">"--version"</span>]) <span class="comment">#命令行空格用 ','隔开</span></span><br><span class="line">print(<span class="string">'console:'</span>, r)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Python 3.6.5 :: Anaconda, Inc.</span><br><span class="line">console: 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>参考链接：<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431927781401bb47ccf187b24c3b955157bb12c5882d000" target="_blank" rel="noopener"><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431927781401bb47ccf187b24c3b955157bb12c5882d000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431927781401bb47ccf187b24c3b955157bb12c5882d000</a></a></p>
<p><a href="https://www.cnblogs.com/kaituorensheng/p/4445418.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/kaituorensheng/p/4445418.html" target="_blank" rel="noopener">https://www.cnblogs.com/kaituorensheng/p/4445418.html</a></a></p>
<p><a href="https://www.cnblogs.com/UncleYong/p/6987112.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/UncleYong/p/6987112.html" target="_blank" rel="noopener">https://www.cnblogs.com/UncleYong/p/6987112.html</a></a></p>
<p><a href="https://www.cnblogs.com/haiyan123/p/7429568.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/haiyan123/p/7429568.html" target="_blank" rel="noopener">https://www.cnblogs.com/haiyan123/p/7429568.html</a></a></p>
<p><a href="https://www.cnblogs.com/lidagen/p/7252247.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/lidagen/p/7252247.html" target="_blank" rel="noopener">https://www.cnblogs.com/lidagen/p/7252247.html</a></a></p>
<p><a href="https://blog.51cto.com/286577399/2051155" target="_blank" rel="noopener"><a href="https://blog.51cto.com/286577399/2051155" target="_blank" rel="noopener">https://blog.51cto.com/286577399/2051155</a></a></p>
<hr>
<p>2019/04/01 22:26</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/31/Python多进程/" data-id="cju9u14ul000juohzsb9menkc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多进程/">多进程</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-robotframework进阶指南" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/26/robotframework进阶指南/" class="article-date">
  <time class="post-time" datetime="2019-03-26T14:17:34.000Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">26</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/26/robotframework进阶指南/">robotframework进阶指南</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/自动化测试/">自动化测试</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Robot-Framework学习指南"><a href="#Robot-Framework学习指南" class="headerlink" title="Robot Framework学习指南"></a>Robot Framework学习指南</h3><ol>
<li><a href="https://www.cnblogs.com/pachongshangdexuebi/p/6689579.html" target="_blank" rel="noopener">环境搭建</a></li>
<li><a href="https://www.cnblogs.com/pachongshangdexuebi/p/6690172.html" target="_blank" rel="noopener">脚本</a></li>
<li><a href="https://www.cnblogs.com/pachongshangdexuebi/p/6693468.html" target="_blank" rel="noopener">关键字介绍</a></li>
<li><a href="https://www.cnblogs.com/pachongshangdexuebi/p/6694139.html" target="_blank" rel="noopener">Screenshot库截图</a></li>
<li><a href="https://www.cnblogs.com/pachongshangdexuebi/p/6694774.html" target="_blank" rel="noopener">Collections字典</a></li>
<li><a href="https://www.cnblogs.com/pachongshangdexuebi/p/6708526.html" target="_blank" rel="noopener">RIDE界面说明</a></li>
<li><a href="https://www.cnblogs.com/pachongshangdexuebi/p/7086577.html" target="_blank" rel="noopener">筛选执行测试用例</a></li>
<li><a href="https://www.cnblogs.com/pachongshangdexuebi/p/6709790.html" target="_blank" rel="noopener">ride标签使用</a></li>
<li><a href="https://www.cnblogs.com/pachongshangdexuebi/p/7112259.html" target="_blank" rel="noopener">创建资源和用户关键词</a></li>
<li><a href="https://www.cnblogs.com/pachongshangdexuebi/p/7112347.html" target="_blank" rel="noopener">selenium2library库</a></li>
<li><a href="https://www.cnblogs.com/pachongshangdexuebi/p/7121420.html" target="_blank" rel="noopener">分层设计</a></li>
<li><a href="https://www.cnblogs.com/pachongshangdexuebi/p/7127224.html" target="_blank" rel="noopener">DatabaseLibrary库</a></li>
<li><a href="https://www.cnblogs.com/pachongshangdexuebi/p/7200360.html" target="_blank" rel="noopener">Robot Framework库</a></li>
<li><a href="https://www.cnblogs.com/pachongshangdexuebi/p/7201131.html" target="_blank" rel="noopener">BuiltIn库</a></li>
<li><a href="https://www.cnblogs.com/pachongshangdexuebi/p/7201766.html" target="_blank" rel="noopener">Collections库</a></li>
<li><a href="https://www.cnblogs.com/pachongshangdexuebi/p/7201983.html" target="_blank" rel="noopener">String库</a></li>
</ol>
<h2 id="3-26-2019-14-33-25-PM"><a href="#3-26-2019-14-33-25-PM" class="headerlink" title="3/26/2019 14:33:25 PM "></a>3/26/2019 14:33:25 PM </h2><p>持续跟踪学习</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/26/robotframework进阶指南/" data-id="cju9u14ul000vuohzwgp24omr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/robotframework/">robotframework</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-pytest-allure搭建" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/26/pytest-allure搭建/" class="article-date">
  <time class="post-time" datetime="2019-03-26T12:32:51.000Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">26</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/26/pytest-allure搭建/">pytest+allure搭建</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/自动化测试/">自动化测试</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>PS：最近在公司工作量不是很大，所以有点时间研究一下各个框架，看看之间的优缺点和特性，方便后面工作测试方案的选择。<br>白天主要是学习和讨论，晚上回来总结或者记录一下环境部署或者实际使用过程中遇到的问题。</p>
<h4 id="pytest：基于unittest的一个测试框架，有很好的扩展性，功能强大，单元测试，持续集成，插件扩展都可以，是一个主流测试框架，支持命令行，支持所有类型的测试类型，简单易读，利用assert断言。"><a href="#pytest：基于unittest的一个测试框架，有很好的扩展性，功能强大，单元测试，持续集成，插件扩展都可以，是一个主流测试框架，支持命令行，支持所有类型的测试类型，简单易读，利用assert断言。" class="headerlink" title="pytest：基于unittest的一个测试框架，有很好的扩展性，功能强大，单元测试，持续集成，插件扩展都可以，是一个主流测试框架，支持命令行，支持所有类型的测试类型，简单易读，利用assert断言。"></a>pytest：基于unittest的一个测试框架，有很好的扩展性，功能强大，单元测试，持续集成，插件扩展都可以，是一个主流测试框架，支持命令行，支持所有类型的测试类型，简单易读，利用assert断言。</h4><h4 id="allure：一款好看的报告框架"><a href="#allure：一款好看的报告框架" class="headerlink" title="allure：一款好看的报告框架"></a>allure：一款好看的报告框架</h4><h3 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h3><h4 id="1-版本支持"><a href="#1-版本支持" class="headerlink" title="1.版本支持"></a>1.版本支持</h4><ul>
<li>Python版本3.6.5</li>
<li>win10操作系统</li>
<li>pytest 3.5.1（公司用的是4.0.2）</li>
<li><code>pytest-allure-adaptor</code> allure的python支持</li>
<li>ps: 网上说不要安装<code>allure-pytest</code>库，会报错</li>
<li>JDK1.8+<h4 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h4></li>
<li>jdk安装 <a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">下载</a> 下载最新版本就行javac 10.0.2，配置环境变量</li>
<li>利用Anaconda安装Python <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="noopener">清华镜像</a> 各种环境变量加上</li>
<li>安装pytest <code>pip install pytest -i http://pypi.douban.com/simple --trusted-host pypi.douban.com</code></li>
<li>安装pytest-allure-adapto <code>pip install pytest-allure-adaptor -i http://pypi.douban.com/simple --trusted-host pypi.douban.com</code></li>
<li>安装方式1,scoopa安装allure：<ul>
<li>win10 PowerShell下执行 <code>set-executionpolicy remotesigned -s cu</code> 选<code>是</code></li>
<li><code>iex (new-object net.webclient).downloadstring(&#39;https://get.scoop.sh&#39;)</code></li>
<li><code>scoop install allure</code></li>
</ul>
</li>
<li>安装方式2，zip下载：<ul>
<li>百度云盘地址：链接：<a href="https://pan.baidu.com/s/1FnA0vrZy3dD1eyc1h5o6qQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1FnA0vrZy3dD1eyc1h5o6qQ</a> 提取码：xmdd </li>
<li>解压到任意盘下，将加压目录下的bin和lib文件夹设置为环境变量</li>
<li>cmd执行<code>allure --version</code> 显示：2.10.0版本<h4 id="3-执行测试用例"><a href="#3-执行测试用例" class="headerlink" title="3.执行测试用例"></a>3.执行测试用例</h4></li>
</ul>
</li>
<li><p>测试代码test_case.py<br></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_01</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="string">"this"</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="string">'h'</span> <span class="keyword">in</span> x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_02</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="string">"hello"</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="string">'x'</span> <span class="keyword">in</span> x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_add</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> add(<span class="number">1</span>,<span class="number">1</span>) == <span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试文件目录下开启cmd控制台 执行<code>pytest</code> 打印:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10785</span>@YuChou MINGW64 /f/pythonFiles/robottest</span><br><span class="line">$ pytest</span><br><span class="line">============================= test session starts =============================</span><br><span class="line">platform win32 -- Python <span class="number">3.6</span><span class="number">.5</span>, pytest<span class="number">-3.5</span><span class="number">.1</span>, py<span class="number">-1.5</span><span class="number">.3</span>, pluggy<span class="number">-0.6</span><span class="number">.0</span></span><br><span class="line">rootdir: F:\pythonFiles\robottest, inifile:</span><br><span class="line">plugins: remotedata<span class="number">-0.2</span><span class="number">.1</span>, openfiles<span class="number">-0.3</span><span class="number">.0</span>, doctestplus<span class="number">-0.1</span><span class="number">.3</span>, arraydiff<span class="number">-0.2</span>, allure-adaptor<span class="number">-1.7</span><span class="number">.10</span></span><br><span class="line">collected <span class="number">3</span> items</span><br><span class="line"></span><br><span class="line">test_case.py .F.                                                         [<span class="number">100</span>%]</span><br><span class="line"></span><br><span class="line">================================== FAILURES ===================================</span><br><span class="line">___________________________________ test_02 ___________________________________</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_02</span><span class="params">()</span>:</span></span><br><span class="line">        x = <span class="string">"hello"</span></span><br><span class="line">&gt;       <span class="keyword">assert</span> <span class="string">'x'</span> <span class="keyword">in</span> x</span><br><span class="line">E       AssertionError: <span class="keyword">assert</span> <span class="string">'x'</span> <span class="keyword">in</span> <span class="string">'hello'</span></span><br><span class="line"></span><br><span class="line">test_case.py:<span class="number">15</span>: AssertionError</span><br><span class="line">===================== <span class="number">1</span> failed, <span class="number">2</span> passed <span class="keyword">in</span> <span class="number">0.07</span> seconds ======================</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br></p>
<ul>
<li>执行 <code>pytest --alluredir=reports</code>，可以发现文件目录下生成reports文件夹,文件: 8ebdf67e-8a6d-483a-bd47-1fef91e62eda-testsuite.xml</li>
<li>再在测试目录下执行<code>allure generate reports</code>，显示<code>Report successfully generated to allure-report</code>,查看allure-reports目录，发现各种文件和目录，用firefox浏览器打开index.html<br>(ps:不是用chrome不是用IE)。或者在pycharm下右键选择<code>Open in Browser</code> 选择chrome也可以。可以看到好看的报告界面。<h4 id="4-定制报告和扩展"><a href="#4-定制报告和扩展" class="headerlink" title="4.定制报告和扩展"></a>4.定制报告和扩展</h4></li>
<li>当然前面的报告界面是默认的，allure的灵活和扩展性给与了更多私人定制，参考 <a href="https://www.cnblogs.com/xiaoxi-3-/p/9492534.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaoxi-3-/p/9492534.html</a>。</li>
<li>allure支持与Jenkins集成</li>
</ul>
<hr>
<p>3/26/2019 10:20:12 PM </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/26/pytest-allure搭建/" data-id="cju9u14ul000puohz01rgwmfm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pytest/">pytest</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-Pycharm-Python3-6-Robotframework3-1-1" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/25/Pycharm-Python3-6-Robotframework3-1-1/" class="article-date">
  <time class="post-time" datetime="2019-03-25T15:25:05.000Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">25</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/25/Pycharm-Python3-6-Robotframework3-1-1/">Pycharm+Python3.6+Robotframework3.1.1</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/测试框架/">测试框架</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Pycharm结合Robotframework执行自动化测试"><a href="#Pycharm结合Robotframework执行自动化测试" class="headerlink" title="Pycharm结合Robotframework执行自动化测试"></a>Pycharm结合Robotframework执行自动化测试</h2><p>####今天发现pycharm下可以开发robotframework，记录下：<br>1.<strong>安装语法高亮IntelliBot插件：</strong><br><br><img src="http://149.248.3.74/installbot.png" alt="安装插件"><br><br>2.<strong>配置文件类型识别</strong><br><br><img src="http://149.248.3.74/conffiletype.jpg" alt="配置识别"><br><br>3.<strong>suite的运行配置</strong><br></p>
<ul>
<li>-d results $FileName$<br></li>
<li>$FileDir$<br><img src="http://149.248.3.74/suit.jpg" alt="suite运行配置"><br><br>4.<strong>case的运行配置</strong><br></li>
<li>-d results -t “$SelectedText$” ./<br></li>
<li>$FileDir$</li>
</ul>
<p><img src="http://149.248.3.74/case.jpg" alt="case运行配置"></p>
<p>5.<strong>简单代码块test.txt</strong><br></p>
<pre><code>*** Settings ***
Library           Selenium2Library

*** Test Cases ***
Chrome测试
    Open Browser    http://www.baidu.com    chrome
    Input Text    id=kw    test
    Click button    id=su
       Sleep    1.5
    Capture Page Screenshot    hello.png
        Close Browser
</code></pre><p>6.<strong>运行</strong></p>
<p>suit运行:<br><br><img src="http://149.248.3.74/out1.jpg" alt="out1"><br><br>case运行:<br><br><img src="http://149.248.3.74/out2.jpg" alt="out2"></p>
<h4 id="f-k，明明公司可以的，还特意检查了"><a href="#f-k，明明公司可以的，还特意检查了" class="headerlink" title="f**k，明明公司可以的，还特意检查了"></a>f**k，明明公司可以的，还特意检查了</h4><blockquote>
<p>3.1的robotframework开始使用robot解析器 其他pybot，jybot ，ipybot 都不用了</p>
</blockquote>
<p>7.<strong>问题排查</strong><br></p>
<h4 id="选错误了。。。。。。近视比较严重-滑稽"><a href="#选错误了。。。。。。近视比较严重-滑稽" class="headerlink" title="选错误了。。。。。。近视比较严重(滑稽)"></a>选错误了。。。。。。近视比较严重(滑稽)</h4><p><img src="http://149.248.3.74/error.jpg" alt="滑稽"><br>8.<strong>路径也有问题</strong>：<br></p>
<ol>
<li>suit: <code>-d results $FileDir$</code><br></li>
<li>case: <code>-d results $FileName$</code></li>
</ol>
<p><br><br>9.<strong>再来一次</strong><br><br></p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p><img src="http://149.248.3.74/go1.jpg" alt="输出"></p>
<h3 id="报告"><a href="#报告" class="headerlink" title="报告"></a>报告</h3><p><img src="http://149.248.3.74/file.jpg" alt="报告"></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li>安装完插件需要重启pycharm</li>
<li>如果python环境下或者Anaconda环境下的Scripts文件夹有加入环境变量，可以在系统cmd窗口  <code>robot.exe -h</code> 查看全部命令</li>
<li>Python版本3.6+Robotframework3.1.1</li>
<li>遇到了再来补充</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/25/Pycharm-Python3-6-Robotframework3-1-1/" data-id="cju9u14tq0001uohz36pzaw1i" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/robotframework/">robotframework</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/自动化测试/">自动化测试</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-unittest框架配置使用" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/24/unittest框架配置使用/" class="article-date">
  <time class="post-time" datetime="2019-03-24T03:03:29.000Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">24</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/24/unittest框架配置使用/">unittest框架配置使用</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/测试/">测试</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h5 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h5><ul>
<li>Python3.7</li>
<li>Unittest 自带版本</li>
<li>HtmlTestRunner 优化版(开源)<h5 id="HtmlTestRunner安装方法"><a href="#HtmlTestRunner安装方法" class="headerlink" title="HtmlTestRunner安装方法"></a>HtmlTestRunner安装方法</h5></li>
<li><code>pip install html-testRunner</code> 安装完直接可以调用</li>
<li>优化版本：<a href="https://github.com/findyou/HTMLTestRunnerCN.git" target="_blank" rel="noopener">手动下载地址</a>，如果是利用Anaconda安装python的需要将下载的HTMLTestReportCN.py和HTMLTestReportEN.py文放在\anaconda\Lib\下供调用。<a href="https://www.cnblogs.com/myal/p/9337392.html" target="_blank" rel="noopener">参考博客</a></li>
</ul>
<h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><h4 id="Pycharm环境下使用"><a href="#Pycharm环境下使用" class="headerlink" title="Pycharm环境下使用"></a>Pycharm环境下使用</h4><ul>
<li>创建project，选择系统的env</li>
<li>创建API文件夹，在此文件夹下创建CaseOne.py文件</li>
<li>选择 <code>http://httpbin.org/</code>网站作为测试网站(任打任挨的网站)</li>
<li><p>程序: <br></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> exceptions</span><br><span class="line"><span class="keyword">from</span> HTMLTestReportCN <span class="keyword">import</span> HTMLTestRunner <span class="comment">#1.导入第三方报表库</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.继承unittest.TestCase类  --》同时 继承了其断言和setUpClass、setUp、tearDownClass、tearDown</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3.此方法是测试用例执行前调用，初始化，例如连接数据库、登录网址保持session</span></span><br><span class="line">    <span class="comment"># 同时还有setUp()方法，二者区别是前者是所有用例开始前初始化一次，后者是每个test都会初始化一次</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUpClass</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(<span class="string">"excute"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_Get</span><span class="params">(self)</span>:</span> <span class="comment">#4.测试get发送数据到网址是否成功，返回的数据是包含发送的数据则成功</span></span><br><span class="line">        url = <span class="string">"http://httpbin.org/get"</span></span><br><span class="line">        formdata = &#123;</span><br><span class="line">            <span class="string">"user"</span>: <span class="string">"yu"</span>,</span><br><span class="line">            <span class="string">"method"</span>: <span class="string">"get"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            res = requests.get(url, params=formdata) <span class="comment">#这里用params 不要用data</span></span><br><span class="line">            res.encoding = res.apparent_encoding</span><br><span class="line">            <span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">                resp = res.json()<span class="comment"># 返回的是字典 若使用res.text需要用json.loads()转成字典</span></span><br><span class="line">        <span class="keyword">except</span> exceptions.RequestException <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> <span class="string">"error %s"</span> % e</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line">        self.assertIn(<span class="string">"user"</span>,  list(resp[<span class="string">"args"</span>].keys()), msg=<span class="string">"user没有返回，实际返回的是&#123;&#125;"</span>.format(resp))<span class="comment">#断言1</span></span><br><span class="line">        self.assertIn(<span class="string">"method"</span>, list(resp[<span class="string">"args"</span>].keys()), msg=<span class="string">"user没有返回，实际返回的是&#123;&#125;"</span>.format(resp))<span class="comment">#断言2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_Post</span><span class="params">(self)</span>:</span><span class="comment">#5.测试post发送数据到网址是否成功，返回的数据是包含发送的数据则成功</span></span><br><span class="line">        url = <span class="string">"http://httpbin.org/post"</span></span><br><span class="line">        formdata = &#123;</span><br><span class="line">            <span class="string">"USER"</span>: <span class="string">"YU"</span>,</span><br><span class="line">            <span class="string">"METHOD"</span>: <span class="string">"GET"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            res = requests.post(url, params=formdata) <span class="comment"># params和data</span></span><br><span class="line">            res.encoding = res.apparent_encoding</span><br><span class="line">            <span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">                resp = res.json()<span class="comment"># 返回的是字典 若使用res.text需要用json.loads()转成字典</span></span><br><span class="line">        <span class="keyword">except</span> exceptions.RequestException <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> <span class="string">"error %s"</span> % e</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line">        self.assertIn(<span class="string">"USER"</span>,  list(resp[<span class="string">"args"</span>].keys()), msg=<span class="string">"user没有返回，实际返回的是&#123;&#125;"</span>.format(resp))<span class="comment">#断言1</span></span><br><span class="line">        self.assertIn(<span class="string">"METHOD"</span>, list(resp[<span class="string">"args"</span>].keys()), msg=<span class="string">"user没有返回，实际返回的是&#123;&#125;"</span>.format(resp))<span class="comment">#断言2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 6.此方法是测试用用例结束清理环境，例如退出连接数据库、退出登录网址保持session</span></span><br><span class="line">    <span class="comment"># 同时还有tearDown()方法，二者区别是前者是所有用例结束时清理一次，后者是每个test都会清理一次</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_Equal</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertEqual(<span class="number">3</span>, <span class="number">1</span>+<span class="number">1</span>, msg=<span class="string">"1+1=3？"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDownClass</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(<span class="string">"test over"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    unittest.main(verbosity=<span class="number">2</span>) <span class="comment">#在unittest.main()中加 verbosity 参数可以控制输出的错误报告的详细程度，默认是 1，如果设为 0，则不输出每一用例的执行结果，即没有上面的结果中的第1行；如果设为 2，则输出详细的执行结果，如下：</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>以上程序执行输出：<br><br><img src="http://149.248.3.74/unittest/%e8%be%93%e5%87%ba1.png" alt="输出1"></p>
</li>
<li><p>这个输出其实是pytest框架执行测试用例时候的输出端，pycharm默认直接调用了pytest，因为我早就安装了pytest，没装应该是调用unittest的框架输出<br><img src="http://149.248.3.74/unittest/pytest%e8%be%93%e5%87%ba.jpg" alt="输出"></p>
</li>
<li><p>修改环境，换成unittest的</p>
<ul>
<li>方法一，修改系统默认的测试框架，直接修改(注意：测试文件第一次运行是用什么环境，即使修改了后面还是会用第一次运行的环境)：<br><img src="http://149.248.3.74/unittest/pytest%e7%8e%af%e5%a2%83.jpg" alt="第一步"></li>
</ul>
<ul>
<li><p>方法二，设置运行时候的框架：</p>
<ul>
<li>step1:编辑一个要用的测试环境<br><img src="http://149.248.3.74/unittest/%e6%96%b9%e6%b3%952.jpg" alt="step1"></li>
<li>step2:<br><img src="http://149.248.3.74/unittest/step2.jpg" alt="step2"></li>
<li>step3:这样选<br><img src="http://149.248.3.74/unittest/step3.jpg" alt="step3"></li>
<li>step4:改名字，选文件<br><img src="http://149.248.3.74/unittest/step4.jpg" alt="step4"></li>
<li>step5:执行<br><img src="http://149.248.3.74/unittest/step5.jpg" alt="step5"></li>
<li>step6:查看新的报告<br><img src="http://149.248.3.74/unittest/step6.jpg" alt="step6"></li>
<li><strong>同样的测试文件的不同输出：</strong><br><img src="http://149.248.3.74/unittest/%e8%be%93%e5%87%ba2.jpg" alt="输出2"></li>
</ul>
</li>
<li><p><strong>注意：按照上述方法，选择普通模式才能生成html报表，选择其他框架模式都不可以</strong></p>
</li>
</ul>
</li>
<li><p>使用HTMLTestRunner生成报表，修改代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">"执行了if————namme"</span>)</span><br><span class="line">    <span class="comment"># unittest.main(verbosity=2) #使用套件不要用这执行</span></span><br><span class="line">    f = open(<span class="string">"F:\\pythonFiles\\UnittestTry\\API\\report.html"</span>, <span class="string">"wb"</span>)</span><br><span class="line">    suit = unittest.TestSuite()<span class="comment">#测试套件 一个组的测试用例</span></span><br><span class="line">    suit.addTest(MyTest(<span class="string">"test_Get"</span>))</span><br><span class="line">    suit.addTest(MyTest(<span class="string">"test_Post"</span>))</span><br><span class="line">    suit.addTest(MyTest(<span class="string">"test_Equal"</span>))</span><br><span class="line">    runner = HTMLTestRunner(stream=f, title=<span class="string">"test"</span>,description=<span class="string">"第一个报表"</span>)</span><br><span class="line">    runner.run(suit)</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行输出：<br>其中<code>.</code>表示通过，<code>F</code>表示执行不通过<br><img src="http://149.248.3.74/unittest/out.jpg" alt="out"><br></p>
</li>
<li>生成报表<br><br><img src="http://149.248.3.74/unittest/report.jpg" alt="报表位置"><br><br><img src="http://149.248.3.74/unittest/html.jpg" alt="报表预览"><br><h2 id="其他扩展或注意事项"><a href="#其他扩展或注意事项" class="headerlink" title="其他扩展或注意事项"></a>其他扩展或注意事项</h2><ul>
<li>命令行运行</li>
</ul>
</li>
<li><code>python -m unittest test_1.py test_2.py</code> 测试多个模块</li>
<li><code>python -m unittest test_1.TestClass</code> 测试某个测试类</li>
<li><code>python -m unittest test_1.TestClass.test_method</code> 测试某个测试方法</li>
<li><code>python -m unittest -v test_module</code> 显示详细结果</li>
<li><code>python -m unittest -h</code> 帮助<ul>
<li>所有测试方法名称需要以<code>test</code>开头，测试类需要<code>Test</code>开头</li>
<li>常见断言：msg错误说明，自己定义</li>
</ul>
</li>
<li><code>assertEqual(self, first, second, msg=None)</code> 判断两个参数相等</li>
<li><code>assertNotEqual(self, first, second, msg=None)</code> 判断两个参数不相等</li>
<li><code>assertIn(self, member, container, msg=None)</code> 判断是字符串是否包含</li>
<li><code>assertNotIn(self, member, container, msg=None)</code> 判断是字符串是否不包含</li>
<li><code>assertTrue(self, expr, msg=None)</code> 判断是否为真</li>
<li><code>assertFalse(self, expr, msg=None)</code> 判断是否为假</li>
<li><code>assertIsNone(self, obj, msg=None)</code> 判断是否为None</li>
<li><code>assertIsNotNone(self, obj, msg=None)</code> 判断是否不为None</li>
<li><a href="https://docs.python.org/2.7/library/unittest.html#unittest.TestCase.debug" target="_blank" rel="noopener">unittest常见断言方法</a><ul>
<li>Test fixtures：</li>
</ul>
</li>
<li>fixture表示tests运行前需要做的准备工作以及结束后的清理工作。比如，创建临时/代理数据库、目录或启动一个服务器进程<ul>
<li>Text Suite：</li>
</ul>
</li>
<li>test suite是test case的合集，通常用test suite将test case汇总然后一起执行<ul>
<li>test runner：</li>
</ul>
</li>
<li>test runner是一个执行器，它可以执行case并提供结果给用户。它可以提供图形界面、文本界面或者返回一个值表示测试结果。<ul>
<li><a href="https://blog.csdn.net/ljl6158999/article/details/80994979" target="_blank" rel="noopener">更多内容</a></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/24/unittest框架配置使用/" data-id="cju9u14v1000yuohzumzjm7mz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/测试框架/">测试框架</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-常见的视频传输协议：RTSP-RTMP-HLS" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/22/常见的视频传输协议：RTSP-RTMP-HLS/" class="article-date">
  <time class="post-time" datetime="2019-03-22T14:26:49.000Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">22</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/22/常见的视频传输协议：RTSP-RTMP-HLS/">常见的视频传输协议：RTSP/RTMP/HLS</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/协议/">协议</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="RTSP协议"><a href="#RTSP协议" class="headerlink" title="RTSP协议"></a>RTSP协议</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><ul>
<li>RTSP是一个基于文本的多媒体播放控制协议，属于应用层。</li>
<li>对应的协议标准是RFC2326</li>
<li>主要用来控制具有实时特性的数据的发送，但是其本身并不用于传送流媒体数据，而必须依赖下层传输协议(RTCP/RTP)所提供的服务来完成流媒体数据的发送。<h5 id="关键词：基于文本、应用层、RFC2326、实时、依赖下层传输协议"><a href="#关键词：基于文本、应用层、RFC2326、实时、依赖下层传输协议" class="headerlink" title="关键词：基于文本、应用层、RFC2326、实时、依赖下层传输协议"></a>关键词：基于文本、应用层、RFC2326、实时、依赖下层传输协议</h5></li>
</ul>
<h4 id="2-作用"><a href="#2-作用" class="headerlink" title="2.作用"></a>2.作用</h4><ul>
<li>控制信息</li>
<li>操作方法</li>
<li>状态码</li>
<li>描述与RTP之间的交互操作</li>
<li>流程：internet–&gt;IP–&gt;(UDP/TCP)–(RTP/RTCP/RTSP)–&gt;Video/Audio</li>
</ul>
<h4 id="3-交互过程"><a href="#3-交互过程" class="headerlink" title="3.交互过程"></a>3.交互过程</h4><pre><code>+ C-&gt;S(OPTION request):Client询问Server有哪些方法可用
+ S-&gt;C(OPTION response):Server回应信息中包含的所有方法
+ C-&gt;S(DESCRIBE request):Client请求得到Server提供的媒体初始化描述信息
+ S-&gt;C(DESCRIBE response):Server回应媒体初始化信息主要是SDP(会话描述协议)
+ C-&gt;S(SETUP request):设置会话属性及传输模式，建立会话
+ S-&gt;C(SETUP response):Server建立会话，返回会话标识符以及会话相关信息
+ C-&gt;S(PLAY request):Client请求播放
+ S-&gt;(PLAY response):Server回应播放请求信息
+ S-&gt;C(Media Data Transfer):发送流媒体数据
+ C-&gt;S(TEARDOWN request):Client请求关闭会话
+ S-&gt;C(TEARDOWN response):Server回应关闭请求会话
</code></pre><h4 id="4-RTSP报文"><a href="#4-RTSP报文" class="headerlink" title="4.RTSP报文"></a>4.RTSP报文</h4><ul>
<li>OPTIONS请求：客户端向服务器询问可用的方法</li>
<li>DESCRIBE请求：客户端向服务器请求媒体资源描述，服务器端通过SDP(Session Description Protocol)格式回应客户端的请求。资源描述中会列出所请求媒体的媒体流及其相关信息</li>
<li>SETUP请求：确定了具体的媒体流如何传输，该请求必须在PLAY请求之前发送。SETUP请求包含媒体流的URL和客户端用于接收RTP数据(audio or video)的端口以及接收RTCP数据(meta information)的端口。服务器端的回复通常包含客户端请求参数的确认，并会补充缺失的部分，比如服务器选择的发送端口</li>
<li>PLAY请求：播放一个或全部媒体流，PLAY请求中可指定播放的range，若未指定，则从媒体流的开始播放到结束</li>
<li>PAUSE请求：暂停一个或所有媒体流，后续可通过PLAY请求恢复播放。若参数range存在，则指明在何处暂停，若该参数不存在，则暂停立即生效</li>
<li>TEARDOWN请求：结束会话</li>
<li>GET_PARAMETER / SET_PARAMETER请求: 检索/设置媒体流的参数值，不携带消息体的GET_PARAMETER可用来测试服务器端或客户端是否可通(类似ping的功能)。<h4 id="5-RTSP认证"><a href="#5-RTSP认证" class="headerlink" title="5.RTSP认证"></a>5.RTSP认证</h4></li>
<li>RTSP认证主要分两种：基本认证（basic authentication）和摘要认证（digest authentication）</li>
<li>基本认证是http 1.0提出的认证方案，其消息传输不经过加密转换因此存在严重的安全隐患（base64编码）</li>
<li>摘要认证是http 1.1提出的基本认证的替代方案，其消息经过MD5哈希转换因此具有更高的安全性。<h4 id="6-RTSP基本认证"><a href="#6-RTSP基本认证" class="headerlink" title="6.RTSP基本认证"></a>6.RTSP基本认证</h4></li>
<li>客户端发送DESCRIBE请求到服务端，RTSP服务端认为没有通过认证，发出WWW-Authenticate认证响应</li>
<li>客户端携带Authorization串再次发出DESCRIBE请求<h4 id="7-RTSP摘要认证"><a href="#7-RTSP摘要认证" class="headerlink" title="7.RTSP摘要认证"></a>7.RTSP摘要认证</h4></li>
<li>客户端发送DESCRIBE请求，服务器端返回401错误，提示未认证并以nonce质询</li>
<li>客户端以用户名，密码，nonce，HTTP方法，请求的URI等信息为基础产生response信息进行反馈</li>
<li>服务器对客户端反馈的response进行校验</li>
</ul>
<h3 id="RTMP协议"><a href="#RTMP协议" class="headerlink" title="RTMP协议"></a>RTMP协议</h3><ul>
<li>RTMP协议是Real Time Message Protocol(实时信息传输协议)的缩写，它是由Adobe公司提出的一种应用层的协议</li>
<li>RTMP一般采用TCP作为传输层，在基于传输层协议的链接建立完成后，RTMP协议也要客户端和服务器通过“握手”来建立基于传输层链接之上的RTMP Connection链接</li>
<li>RTMP协议中基本的数据单元称为消息。消息被拆分成更小的消息块进行传输，接收端再进行组合并解封装后得到媒体数据</li>
<li>速度快，误码率低，延迟低RTMP 是专为流媒体服务而生，协议在制定的时候就考虑到很多底层的优化消息块的传输能够提供更加稳定的直播环境</li>
<li>RTMP视频的封装格式是基于flv，支持flash播放，低延时，常常用于互联网直播应用，但在HTML5中需要使用插件才能支持，一般不支持IOS设备<h3 id="HLS协议"><a href="#HLS协议" class="headerlink" title="HLS协议"></a>HLS协议</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4></li>
<li>HTTP Live Streaming，是Apple的开放标准，基于HTTP流，它最初是苹果公司针对iPhone、iPod、iTouch和iPad等移动设备而开发的流，现在见到在桌面也有很多应用了，由于是基于HTTP的，因此很多HTTP的优点都得到了继承。<h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h4></li>
<li>将流媒体切分为若干 TS 片段（比如每10秒一段），然后通过一个扩展的 m3u 列表文件将这些 TS 片段集中起来供客户端播放器接收。<h4 id="3-流程功能块"><a href="#3-流程功能块" class="headerlink" title="3.流程功能块"></a>3.流程功能块</h4></li>
<li>视频输入或者采集设备给Media encoder</li>
<li>Media encoder：负责将视频源转码成H264的视频数据给stream segmenter模块</li>
<li>stream segmenter：模块将视频切片，得到index file（m3u8）和ts文件给Distribution</li>
<li>Distribution：一个普通的HTTP文件服务器传输给使用 者client</li>
<li>client<h4 id="4-视频文件索引-m3u8文件-？"><a href="#4-视频文件索引-m3u8文件-？" class="headerlink" title="4.视频文件索引(.m3u8文件)？"></a>4.视频文件索引(.m3u8文件)？</h4></li>
<li>#EXTM3U：每个m3u文件第一行必须是这个tag</li>
<li>#EXT-X-TARGETDURATION：指定最大的媒体段时间长（秒）</li>
<li>#EXT-X-MEDIA-SEQUENCE：第一个媒体段的序列号，默认为0</li>
<li>#EXTINF：指出媒体段的时间长度，紧接着指定媒体段的URL</li>
<li>#EXT-X-ENDLIST：媒体列表结束<h4 id="5-优缺点"><a href="#5-优缺点" class="headerlink" title="5.优缺点"></a>5.优缺点</h4></li>
<li>HLS协议一旦切分TS片段完成，之后的分发过程完全不需要额外使用任何专门软件，普通的网络服务器即可，大大降低了 CDN 边缘服务器的配置要求。</li>
<li>分发使用的协议是最常见 HTTP，代理服务器对这个协议的缓存优化相当成熟，而很少有代理服务器对 RTSP 的进行缓存优化。这对播放（软）实时视频有相当大的优势，因为这样分发后，对源服务器的负载压力小得多。</li>
<li>HLS支持自适应码率流播（adaptive streaming）。效果就是客户端会根据网络状况自动选择不同码率的视频流，并且自动在二者间随意切换。实现方法是服务器端提供多码率视频流，并且在列表文件中注明</li>
<li>HLS协议用 TS 而不是 MP4，因为两个 TS 片段可以无缝拼接，播放器能连续播放，而 MP4 文件由于编码方式的原因，两段 MP4 不能无缝拼接</li>
<li>IOS、Android、HTML5原生支持。</li>
<li>缺点：直播应用中，相比于RTMP延时长，基本在10秒以上。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/22/常见的视频传输协议：RTSP-RTMP-HLS/" data-id="cju9u14v10018uohz1s1npbt5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/视频协议/">视频协议</a></li></ul>

    </footer>
  </div>
  
</article>




  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">next &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">YuChou</h1>
    <h2 class="blog-subtitle">Dream of walking the world with techbology</h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives/" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories/" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags/" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="http://149.248.3.74/Photos/titleImage/AF359E06C1819F0FA30D32DA9F0E8EB6.png">
    <h2 class="author">YuChou</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>17</strong><br>文章</div></a>
      <a href="/categories"><div><strong>11</strong><br>分类</div></a>
      <a href="/tags"><div><strong>16</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="https://github.com/mrzhouyu" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>SomeLink</h2>
      
        <a class="hvr-bounce-in" href="https://www.zhihu.com" target="_blank" title="Zhihu">
          Zhihu
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2018 - 2019 YuChou<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a href="https://github.com/ShanaMaid/hexo-theme-shana">Shana</a>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  <link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">
  <script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>



  <link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">
  <script src="/plugin/galmenu/GalMenu.js"></script>
  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/tags" title="" class="menuItem">标签</a>
          
            <a href="/categories" title="" class="menuItem">分类</a>
          
            <a href="/archives" title="" class="menuItem">归档</a>
          
            <a href="/xxxxxxxxx" title="" class="menuItem">xxx</a>
          
            <a href="/xxxxxxx" title="" class="menuItem">xxxx</a>
          
        </div>
        
          <audio id="audio" src="#"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>
<script src="/js/script.js"></script>



  </div>
</body>
</html>