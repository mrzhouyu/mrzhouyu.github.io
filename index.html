<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>YuChou</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="YuChou">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="YuChou">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="YuChou">
  
    <link rel="alternate" href="/atom.xml" title="YuChou" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/plugin/bganimation/bg.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="http://149.248.3.74/Photos/titleImage/AF359E06C1819F0FA30D32DA9F0E8EB6.png">
    <h2 class="author">YuChou</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>12</strong><br>文章</div></a>
      <a href="/categories"><div><strong>8</strong><br>分类</div></a>
      <a href="/tags"><div><strong>11</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives/" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories/" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags/" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main">
  
    <article id="post-d" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/25/d/" class="article-date">
  <time class="post-time" datetime="2019-03-25T15:27:49.000Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">25</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/25/d/">d</a>
    </h1>
  

        <div>
          
          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/25/d/" data-id="cjtoi9xbu0001kghzoh0jz7i3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-g" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/25/g/" class="article-date">
  <time class="post-time" datetime="2019-03-25T15:27:45.000Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">25</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/25/g/">g</a>
    </h1>
  

        <div>
          
          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/25/g/" data-id="cjtoi9xc60005kghz3qodao4g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-Pycharm-Python3-6-Robotframework3-1-1" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/25/Pycharm-Python3-6-Robotframework3-1-1/" class="article-date">
  <time class="post-time" datetime="2019-03-25T15:25:05.000Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">25</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/25/Pycharm-Python3-6-Robotframework3-1-1/">Pycharm+Python3.6+Robotframework3.1.1</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/测试框架/">测试框架</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Pycharm结合Robotframework执行自动化测试"><a href="#Pycharm结合Robotframework执行自动化测试" class="headerlink" title="Pycharm结合Robotframework执行自动化测试"></a>Pycharm结合Robotframework执行自动化测试</h2><p>####今天发现pycharm下可以开发robotframework，记录下：<br>1.<strong>安装语法高亮IntelliBot插件：</strong><br><br><img src="http://149.248.3.74/installbot.png" alt="安装插件"><br><br>2.<strong>配置文件类型识别</strong><br><br><img src="http://149.248.3.74/conffiletype.jpg" alt="配置识别"><br><br>3.<strong>suite的运行配置</strong><br></p>
<ul>
<li>-d results $FileName$<br></li>
<li>$FileDir$<br><img src="http://149.248.3.74/suit.jpg" alt="suite运行配置"><br><br>4.<strong>case的运行配置</strong><br></li>
<li>-d results -t “$SelectedText$” ./<br></li>
<li>$FileDir$</li>
</ul>
<p><img src="http://149.248.3.74/case.jpg" alt="case运行配置"></p>
<p>5.<strong>简单代码块test.txt</strong><br></p>
<pre><code>*** Settings ***
Library           Selenium2Library

*** Test Cases ***
Chrome测试
    Open Browser    http://www.baidu.com    chrome
    Input Text    id=kw    test
    Click button    id=su
       Sleep    1.5
    Capture Page Screenshot    hello.png
        Close Browser
</code></pre><p>6.<strong>运行</strong></p>
<p>suit运行:<br><br><img src="http://149.248.3.74/out1.jpg" alt="out1"><br><br>case运行:<br><br><img src="http://149.248.3.74/out2.jpg" alt="out2"></p>
<h4 id="f-k，明明公司可以的，还特意检查了"><a href="#f-k，明明公司可以的，还特意检查了" class="headerlink" title="f**k，明明公司可以的，还特意检查了"></a>f**k，明明公司可以的，还特意检查了</h4><blockquote>
<p>3.1的robotframework开始使用robot解析器 其他pybot，jybot ，ipybot 都不用了</p>
</blockquote>
<p>7.<strong>问题排查</strong><br></p>
<h4 id="选错误了。。。。。。近视比较严重-滑稽"><a href="#选错误了。。。。。。近视比较严重-滑稽" class="headerlink" title="选错误了。。。。。。近视比较严重(滑稽)"></a>选错误了。。。。。。近视比较严重(滑稽)</h4><p><img src="http://149.248.3.74/error.jpg" alt="滑稽"><br>8.<strong>路径也有问题</strong>：<br></p>
<ol>
<li>suit: <code>-d results $FileDir$</code><br></li>
<li>case: <code>-d results $FileName$</code></li>
</ol>
<p><br><br>9.<strong>再来一次</strong><br><br></p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p><img src="http://149.248.3.74/go1.jpg" alt="输出"></p>
<h3 id="报告"><a href="#报告" class="headerlink" title="报告"></a>报告</h3><p><img src="http://149.248.3.74/file.jpg" alt="报告"></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li>安装完插件需要重启pycharm</li>
<li>如果python环境下或者Anaconda环境下的Scripts文件夹有加入环境变量，可以在系统cmd窗口  <code>robot.exe -h</code> 查看全部命令</li>
<li>Python版本3.6+Robotframework3.1.1</li>
<li>遇到了再来补充</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/25/Pycharm-Python3-6-Robotframework3-1-1/" data-id="cjtoi9xbo0000kghzw3bn9005" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/robotframework/">robotframework</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/自动化测试/">自动化测试</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-unittest框架配置使用" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/24/unittest框架配置使用/" class="article-date">
  <time class="post-time" datetime="2019-03-24T03:03:29.000Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">24</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/24/unittest框架配置使用/">unittest框架配置使用</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/测试/">测试</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h5 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h5><ul>
<li>Python3.7</li>
<li>Unittest 自带版本</li>
<li>HtmlTestRunner 优化版(开源)<h5 id="HtmlTestRunner安装方法"><a href="#HtmlTestRunner安装方法" class="headerlink" title="HtmlTestRunner安装方法"></a>HtmlTestRunner安装方法</h5></li>
<li><code>pip install html-testRunner</code> 安装完直接可以调用</li>
<li>优化版本：<a href="https://github.com/findyou/HTMLTestRunnerCN.git" target="_blank" rel="noopener">手动下载地址</a>，如果是利用Anaconda安装python的需要将下载的HTMLTestReportCN.py和HTMLTestReportEN.py文放在\anaconda\Lib\下供调用。<a href="https://www.cnblogs.com/myal/p/9337392.html" target="_blank" rel="noopener">参考博客</a></li>
</ul>
<h2 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h2><h4 id="Pycharm环境下使用"><a href="#Pycharm环境下使用" class="headerlink" title="Pycharm环境下使用"></a>Pycharm环境下使用</h4><ul>
<li>创建project，选择系统的env</li>
<li>创建API文件夹，在此文件夹下创建CaseOne.py文件</li>
<li>选择 <code>http://httpbin.org/</code>网站作为测试网站(任打任挨的网站)</li>
<li><p>程序: <br></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> exceptions</span><br><span class="line"><span class="keyword">from</span> HTMLTestReportCN <span class="keyword">import</span> HTMLTestRunner <span class="comment">#1.导入第三方报表库</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.继承unittest.TestCase类  --》同时 继承了其断言和setUpClass、setUp、tearDownClass、tearDown</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3.此方法是测试用例执行前调用，初始化，例如连接数据库、登录网址保持session</span></span><br><span class="line">    <span class="comment"># 同时还有setUp()方法，二者区别是前者是所有用例开始前初始化一次，后者是每个test都会初始化一次</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUpClass</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(<span class="string">"excute"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_Get</span><span class="params">(self)</span>:</span> <span class="comment">#4.测试get发送数据到网址是否成功，返回的数据是包含发送的数据则成功</span></span><br><span class="line">        url = <span class="string">"http://httpbin.org/get"</span></span><br><span class="line">        formdata = &#123;</span><br><span class="line">            <span class="string">"user"</span>: <span class="string">"yu"</span>,</span><br><span class="line">            <span class="string">"method"</span>: <span class="string">"get"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            res = requests.get(url, params=formdata) <span class="comment">#这里用params 不要用data</span></span><br><span class="line">            res.encoding = res.apparent_encoding</span><br><span class="line">            <span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">                resp = res.json()<span class="comment"># 返回的是字典 若使用res.text需要用json.loads()转成字典</span></span><br><span class="line">        <span class="keyword">except</span> exceptions.RequestException <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> <span class="string">"error %s"</span> % e</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line">        self.assertIn(<span class="string">"user"</span>,  list(resp[<span class="string">"args"</span>].keys()), msg=<span class="string">"user没有返回，实际返回的是&#123;&#125;"</span>.format(resp))<span class="comment">#断言1</span></span><br><span class="line">        self.assertIn(<span class="string">"method"</span>, list(resp[<span class="string">"args"</span>].keys()), msg=<span class="string">"user没有返回，实际返回的是&#123;&#125;"</span>.format(resp))<span class="comment">#断言2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_Post</span><span class="params">(self)</span>:</span><span class="comment">#5.测试post发送数据到网址是否成功，返回的数据是包含发送的数据则成功</span></span><br><span class="line">        url = <span class="string">"http://httpbin.org/post"</span></span><br><span class="line">        formdata = &#123;</span><br><span class="line">            <span class="string">"USER"</span>: <span class="string">"YU"</span>,</span><br><span class="line">            <span class="string">"METHOD"</span>: <span class="string">"GET"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            res = requests.post(url, params=formdata) <span class="comment"># params和data</span></span><br><span class="line">            res.encoding = res.apparent_encoding</span><br><span class="line">            <span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">                resp = res.json()<span class="comment"># 返回的是字典 若使用res.text需要用json.loads()转成字典</span></span><br><span class="line">        <span class="keyword">except</span> exceptions.RequestException <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> <span class="string">"error %s"</span> % e</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line">        self.assertIn(<span class="string">"USER"</span>,  list(resp[<span class="string">"args"</span>].keys()), msg=<span class="string">"user没有返回，实际返回的是&#123;&#125;"</span>.format(resp))<span class="comment">#断言1</span></span><br><span class="line">        self.assertIn(<span class="string">"METHOD"</span>, list(resp[<span class="string">"args"</span>].keys()), msg=<span class="string">"user没有返回，实际返回的是&#123;&#125;"</span>.format(resp))<span class="comment">#断言2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 6.此方法是测试用用例结束清理环境，例如退出连接数据库、退出登录网址保持session</span></span><br><span class="line">    <span class="comment"># 同时还有tearDown()方法，二者区别是前者是所有用例结束时清理一次，后者是每个test都会清理一次</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_Equal</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertEqual(<span class="number">3</span>, <span class="number">1</span>+<span class="number">1</span>, msg=<span class="string">"1+1=3？"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDownClass</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(<span class="string">"test over"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    unittest.main(verbosity=<span class="number">2</span>) <span class="comment">#在unittest.main()中加 verbosity 参数可以控制输出的错误报告的详细程度，默认是 1，如果设为 0，则不输出每一用例的执行结果，即没有上面的结果中的第1行；如果设为 2，则输出详细的执行结果，如下：</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>以上程序执行输出：<br><br><img src="http://149.248.3.74/unittest/%e8%be%93%e5%87%ba1.png" alt="输出1"></p>
</li>
<li><p>这个输出其实是pytest框架执行测试用例时候的输出端，pycharm默认直接调用了pytest，因为我早就安装了pytest，没装应该是调用unittest的框架输出<br><img src="http://149.248.3.74/unittest/pytest%e8%be%93%e5%87%ba.jpg" alt="输出"></p>
</li>
<li><p>修改环境，换成unittest的</p>
<ul>
<li>方法一，修改系统默认的测试框架，直接修改(注意：测试文件第一次运行是用什么环境，即使修改了后面还是会用第一次运行的环境)：<br><img src="http://149.248.3.74/unittest/pytest%e7%8e%af%e5%a2%83.jpg" alt="第一步"></li>
</ul>
<ul>
<li><p>方法二，设置运行时候的框架：</p>
<ul>
<li>step1:编辑一个要用的测试环境<br><img src="http://149.248.3.74/unittest/%e6%96%b9%e6%b3%952.jpg" alt="step1"></li>
<li>step2:<br><img src="http://149.248.3.74/unittest/step2.jpg" alt="step2"></li>
<li>step3:这样选<br><img src="http://149.248.3.74/unittest/step3.jpg" alt="step3"></li>
<li>step4:改名字，选文件<br><img src="http://149.248.3.74/unittest/step4.jpg" alt="step4"></li>
<li>step5:执行<br><img src="http://149.248.3.74/unittest/step5.jpg" alt="step5"></li>
<li>step6:查看新的报告<br><img src="http://149.248.3.74/unittest/step6.jpg" alt="step6"></li>
<li><strong>同样的测试文件的不同输出：</strong><br><img src="http://149.248.3.74/unittest/%e8%be%93%e5%87%ba2.jpg" alt="输出2"></li>
</ul>
</li>
<li><p><strong>注意：按照上述方法，选择普通模式才能生成html报表，选择其他框架模式都不可以</strong></p>
</li>
</ul>
</li>
<li><p>使用HTMLTestRunner生成报表，修改代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">"执行了if————namme"</span>)</span><br><span class="line">    <span class="comment"># unittest.main(verbosity=2) #使用套件不要用这执行</span></span><br><span class="line">    f = open(<span class="string">"F:\\pythonFiles\\UnittestTry\\API\\report.html"</span>, <span class="string">"wb"</span>)</span><br><span class="line">    suit = unittest.TestSuite()<span class="comment">#测试套件 一个组的测试用例</span></span><br><span class="line">    suit.addTest(MyTest(<span class="string">"test_Get"</span>))</span><br><span class="line">    suit.addTest(MyTest(<span class="string">"test_Post"</span>))</span><br><span class="line">    suit.addTest(MyTest(<span class="string">"test_Equal"</span>))</span><br><span class="line">    runner = HTMLTestRunner(stream=f, title=<span class="string">"test"</span>,description=<span class="string">"第一个报表"</span>)</span><br><span class="line">    runner.run(suit)</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行输出：<br>其中<code>.</code>表示通过，<code>F</code>表示执行不通过<br><img src="http://149.248.3.74/unittest/out.jpg" alt="out"><br></p>
</li>
<li>生成报表<br><br><img src="http://149.248.3.74/unittest/report.jpg" alt="报表位置"><br><br><img src="http://149.248.3.74/unittest/html.jpg" alt="报表预览"><br><h2 id="其他扩展或注意事项"><a href="#其他扩展或注意事项" class="headerlink" title="其他扩展或注意事项"></a>其他扩展或注意事项</h2><ul>
<li>命令行运行</li>
</ul>
</li>
<li><code>python -m unittest test_1.py test_2.py</code> 测试多个模块</li>
<li><code>python -m unittest test_1.TestClass</code> 测试某个测试类</li>
<li><code>python -m unittest test_1.TestClass.test_method</code> 测试某个测试方法</li>
<li><code>python -m unittest -v test_module</code> 显示详细结果</li>
<li><code>python -m unittest -h</code> 帮助<ul>
<li>所有测试方法名称需要以<code>test</code>开头，测试类需要<code>Test</code>开头</li>
<li>常见断言：msg错误说明，自己定义</li>
</ul>
</li>
<li><code>assertEqual(self, first, second, msg=None)</code> 判断两个参数相等</li>
<li><code>assertNotEqual(self, first, second, msg=None)</code> 判断两个参数不相等</li>
<li><code>assertIn(self, member, container, msg=None)</code> 判断是字符串是否包含</li>
<li><code>assertNotIn(self, member, container, msg=None)</code> 判断是字符串是否不包含</li>
<li><code>assertTrue(self, expr, msg=None)</code> 判断是否为真</li>
<li><code>assertFalse(self, expr, msg=None)</code> 判断是否为假</li>
<li><code>assertIsNone(self, obj, msg=None)</code> 判断是否为None</li>
<li><code>assertIsNotNone(self, obj, msg=None)</code> 判断是否不为None</li>
<li><a href="https://docs.python.org/2.7/library/unittest.html#unittest.TestCase.debug" target="_blank" rel="noopener">unittest常见断言方法</a><ul>
<li>Test fixtures：</li>
</ul>
</li>
<li>fixture表示tests运行前需要做的准备工作以及结束后的清理工作。比如，创建临时/代理数据库、目录或启动一个服务器进程<ul>
<li>Text Suite：</li>
</ul>
</li>
<li>test suite是test case的合集，通常用test suite将test case汇总然后一起执行<ul>
<li>test runner：</li>
</ul>
</li>
<li>test runner是一个执行器，它可以执行case并提供结果给用户。它可以提供图形界面、文本界面或者返回一个值表示测试结果。<ul>
<li><a href="https://blog.csdn.net/ljl6158999/article/details/80994979" target="_blank" rel="noopener">更多内容</a></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/24/unittest框架配置使用/" data-id="cjtoi9xd6000okghznfnovw2y" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/测试框架/">测试框架</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-常见的视频传输协议：RTSP-RTMP-HLS" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/22/常见的视频传输协议：RTSP-RTMP-HLS/" class="article-date">
  <time class="post-time" datetime="2019-03-22T14:26:49.000Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">22</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/22/常见的视频传输协议：RTSP-RTMP-HLS/">常见的视频传输协议：RTSP/RTMP/HLS</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/协议/">协议</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="RTSP协议"><a href="#RTSP协议" class="headerlink" title="RTSP协议"></a>RTSP协议</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><ul>
<li>RTSP是一个基于文本的多媒体播放控制协议，属于应用层。</li>
<li>对应的协议标准是RFC2326</li>
<li>主要用来控制具有实时特性的数据的发送，但是其本身并不用于传送流媒体数据，而必须依赖下层传输协议(RTCP/RTP)所提供的服务来完成流媒体数据的发送。<h5 id="关键词：基于文本、应用层、RFC2326、实时、依赖下层传输协议"><a href="#关键词：基于文本、应用层、RFC2326、实时、依赖下层传输协议" class="headerlink" title="关键词：基于文本、应用层、RFC2326、实时、依赖下层传输协议"></a>关键词：基于文本、应用层、RFC2326、实时、依赖下层传输协议</h5></li>
</ul>
<h4 id="2-作用"><a href="#2-作用" class="headerlink" title="2.作用"></a>2.作用</h4><ul>
<li>控制信息</li>
<li>操作方法</li>
<li>状态码</li>
<li>描述与RTP之间的交互操作</li>
<li>流程：internet–&gt;IP–&gt;(UDP/TCP)–(RTP/RTCP/RTSP)–&gt;Video/Audio</li>
</ul>
<h4 id="3-交互过程"><a href="#3-交互过程" class="headerlink" title="3.交互过程"></a>3.交互过程</h4><pre><code>+ C-&gt;S(OPTION request):Client询问Server有哪些方法可用
+ S-&gt;C(OPTION response):Server回应信息中包含的所有方法
+ C-&gt;S(DESCRIBE request):Client请求得到Server提供的媒体初始化描述信息
+ S-&gt;C(DESCRIBE response):Server回应媒体初始化信息主要是SDP(会话描述协议)
+ C-&gt;S(SETUP request):设置会话属性及传输模式，建立会话
+ S-&gt;C(SETUP response):Server建立会话，返回会话标识符以及会话相关信息
+ C-&gt;S(PLAY request):Client请求播放
+ S-&gt;(PLAY response):Server回应播放请求信息
+ S-&gt;C(Media Data Transfer):发送流媒体数据
+ C-&gt;S(TEARDOWN request):Client请求关闭会话
+ S-&gt;C(TEARDOWN response):Server回应关闭请求会话
</code></pre><h4 id="4-RTSP报文"><a href="#4-RTSP报文" class="headerlink" title="4.RTSP报文"></a>4.RTSP报文</h4><ul>
<li>OPTIONS请求：客户端向服务器询问可用的方法</li>
<li>DESCRIBE请求：客户端向服务器请求媒体资源描述，服务器端通过SDP(Session Description Protocol)格式回应客户端的请求。资源描述中会列出所请求媒体的媒体流及其相关信息</li>
<li>SETUP请求：确定了具体的媒体流如何传输，该请求必须在PLAY请求之前发送。SETUP请求包含媒体流的URL和客户端用于接收RTP数据(audio or video)的端口以及接收RTCP数据(meta information)的端口。服务器端的回复通常包含客户端请求参数的确认，并会补充缺失的部分，比如服务器选择的发送端口</li>
<li>PLAY请求：播放一个或全部媒体流，PLAY请求中可指定播放的range，若未指定，则从媒体流的开始播放到结束</li>
<li>PAUSE请求：暂停一个或所有媒体流，后续可通过PLAY请求恢复播放。若参数range存在，则指明在何处暂停，若该参数不存在，则暂停立即生效</li>
<li>TEARDOWN请求：结束会话</li>
<li>GET_PARAMETER / SET_PARAMETER请求: 检索/设置媒体流的参数值，不携带消息体的GET_PARAMETER可用来测试服务器端或客户端是否可通(类似ping的功能)。<h4 id="5-RTSP认证"><a href="#5-RTSP认证" class="headerlink" title="5.RTSP认证"></a>5.RTSP认证</h4></li>
<li>RTSP认证主要分两种：基本认证（basic authentication）和摘要认证（digest authentication）</li>
<li>基本认证是http 1.0提出的认证方案，其消息传输不经过加密转换因此存在严重的安全隐患（base64编码）</li>
<li>摘要认证是http 1.1提出的基本认证的替代方案，其消息经过MD5哈希转换因此具有更高的安全性。<h4 id="6-RTSP基本认证"><a href="#6-RTSP基本认证" class="headerlink" title="6.RTSP基本认证"></a>6.RTSP基本认证</h4></li>
<li>客户端发送DESCRIBE请求到服务端，RTSP服务端认为没有通过认证，发出WWW-Authenticate认证响应</li>
<li>客户端携带Authorization串再次发出DESCRIBE请求<h4 id="7-RTSP摘要认证"><a href="#7-RTSP摘要认证" class="headerlink" title="7.RTSP摘要认证"></a>7.RTSP摘要认证</h4></li>
<li>客户端发送DESCRIBE请求，服务器端返回401错误，提示未认证并以nonce质询</li>
<li>客户端以用户名，密码，nonce，HTTP方法，请求的URI等信息为基础产生response信息进行反馈</li>
<li>服务器对客户端反馈的response进行校验</li>
</ul>
<h3 id="RTMP协议"><a href="#RTMP协议" class="headerlink" title="RTMP协议"></a>RTMP协议</h3><ul>
<li>RTMP协议是Real Time Message Protocol(实时信息传输协议)的缩写，它是由Adobe公司提出的一种应用层的协议</li>
<li>RTMP一般采用TCP作为传输层，在基于传输层协议的链接建立完成后，RTMP协议也要客户端和服务器通过“握手”来建立基于传输层链接之上的RTMP Connection链接</li>
<li>RTMP协议中基本的数据单元称为消息。消息被拆分成更小的消息块进行传输，接收端再进行组合并解封装后得到媒体数据</li>
<li>速度快，误码率低，延迟低RTMP 是专为流媒体服务而生，协议在制定的时候就考虑到很多底层的优化消息块的传输能够提供更加稳定的直播环境</li>
<li>RTMP视频的封装格式是基于flv，支持flash播放，低延时，常常用于互联网直播应用，但在HTML5中需要使用插件才能支持，一般不支持IOS设备<h3 id="HLS协议"><a href="#HLS协议" class="headerlink" title="HLS协议"></a>HLS协议</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4></li>
<li>HTTP Live Streaming，是Apple的开放标准，基于HTTP流，它最初是苹果公司针对iPhone、iPod、iTouch和iPad等移动设备而开发的流，现在见到在桌面也有很多应用了，由于是基于HTTP的，因此很多HTTP的优点都得到了继承。<h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h4></li>
<li>将流媒体切分为若干 TS 片段（比如每10秒一段），然后通过一个扩展的 m3u 列表文件将这些 TS 片段集中起来供客户端播放器接收。<h4 id="3-流程功能块"><a href="#3-流程功能块" class="headerlink" title="3.流程功能块"></a>3.流程功能块</h4></li>
<li>视频输入或者采集设备给Media encoder</li>
<li>Media encoder：负责将视频源转码成H264的视频数据给stream segmenter模块</li>
<li>stream segmenter：模块将视频切片，得到index file（m3u8）和ts文件给Distribution</li>
<li>Distribution：一个普通的HTTP文件服务器传输给使用 者client</li>
<li>client<h4 id="4-视频文件索引-m3u8文件-？"><a href="#4-视频文件索引-m3u8文件-？" class="headerlink" title="4.视频文件索引(.m3u8文件)？"></a>4.视频文件索引(.m3u8文件)？</h4></li>
<li>#EXTM3U：每个m3u文件第一行必须是这个tag</li>
<li>#EXT-X-TARGETDURATION：指定最大的媒体段时间长（秒）</li>
<li>#EXT-X-MEDIA-SEQUENCE：第一个媒体段的序列号，默认为0</li>
<li>#EXTINF：指出媒体段的时间长度，紧接着指定媒体段的URL</li>
<li>#EXT-X-ENDLIST：媒体列表结束<h4 id="5-优缺点"><a href="#5-优缺点" class="headerlink" title="5.优缺点"></a>5.优缺点</h4></li>
<li>HLS协议一旦切分TS片段完成，之后的分发过程完全不需要额外使用任何专门软件，普通的网络服务器即可，大大降低了 CDN 边缘服务器的配置要求。</li>
<li>分发使用的协议是最常见 HTTP，代理服务器对这个协议的缓存优化相当成熟，而很少有代理服务器对 RTSP 的进行缓存优化。这对播放（软）实时视频有相当大的优势，因为这样分发后，对源服务器的负载压力小得多。</li>
<li>HLS支持自适应码率流播（adaptive streaming）。效果就是客户端会根据网络状况自动选择不同码率的视频流，并且自动在二者间随意切换。实现方法是服务器端提供多码率视频流，并且在列表文件中注明</li>
<li>HLS协议用 TS 而不是 MP4，因为两个 TS 片段可以无缝拼接，播放器能连续播放，而 MP4 文件由于编码方式的原因，两段 MP4 不能无缝拼接</li>
<li>IOS、Android、HTML5原生支持。</li>
<li>缺点：直播应用中，相比于RTMP延时长，基本在10秒以上。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/22/常见的视频传输协议：RTSP-RTMP-HLS/" data-id="cjtoi9xdh000tkghzkd2205lq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/视频协议/">视频协议</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-robotframework学习" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/18/robotframework学习/" class="article-date">
  <time class="post-time" datetime="2019-03-18T14:38:07.000Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">18</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/18/robotframework学习/">robotframework初窥</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/自动化测试/">自动化测试</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1.环境准备"></a>1.环境准备</h2><p>###</p>
<ol>
<li>Python环境，利用Anaconda安装集成环境(pip、conda等也一并安装)我这里用默认的Python3.7,确保Scripts、lib、Anaconda等等文件夹加到了环境变量下。 <a href="https://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">下载地址</a></li>
<li>安装robotframwork，<code>python -m pip install -U robotframework</code></li>
<li>安装图形界面：<code>pip install robotframework-ride</code></li>
<li>由于ride是基于用wxPython库开发，这里安装该库 <code>pip install wxPython</code></li>
<li>安装完成，启动：到Anaconda安装目录下的Scripts找到ride.py文件，在此打开cmd控制台，运行<code>python ride.py</code>就可以开启图形界面</li>
<li>步骤5方法启动比较麻烦，可以用一个.bat脚本来减少步骤：任意目录下创建脚本文件夹，该目录下创建两个脚本：rideStart.bat, ride.bat。其中ride.bat内容：<code>python ride.py_path\Scripts\ride.py</code>,rideStart.bat内容：<code>start ride.bat_path\ride.bat</code>。如果是填的是绝对路径，两个脚本随便放哪里都可以。执行rideStart.bat脚本就可以启动。</li>
<li>也可以直接建一个runride.bat到桌面: <code>python -c &quot;from robotide import main; main()&quot;</code>,点击运行即可。</li>
<li>Library安装，因为测试需要用到许多的其他模块，这里需要安装一些库：<code>robotframework-selenium2library</code>、<a href="https://github.com/bulkan/robotframework-requests" target="_blank" rel="noopener">robotframework-requests</a>、<a href="https://github.com/serhatbolsu/robotframework-appiumlibrary" target="_blank" rel="noopener">robotframework-appiumlibrary</a>、<a href="https://github.com/peritus/robotframework-httplibrary" target="_blank" rel="noopener">robotframework-httplibrary</a>、<a href="https://github.com/franz-see/Robotframework-Database-Library" target="_blank" rel="noopener">Robotframework-Database-Library</a>。  pip安装即可，更多参考<a href="https://blog.csdn.net/u013961875/article/details/78670249" target="_blank" rel="noopener">Robot Framework 常用的第三方库</a></li>
<li>浏览器驱动：常见的谷歌、火狐、IE。参考 <a href="https://www.zhoujiayu.top/2019/03/11/Selenium%E4%B8%80%E4%BA%9BAPI%E6%95%B4%E7%90%86/" target="_blank" rel="noopener">Selenium一些API整理</a></li>
</ol>
<h2 id="2-初窥"><a href="#2-初窥" class="headerlink" title="2.初窥"></a>2.初窥</h2><ol>
<li><strong>运行开启脚本创建工程</strong><br><img src="http://149.248.3.74/robotframework/1.png" alt="1"><br></li>
<li><strong>创建测试套件</strong> <br><br><img src="http://149.248.3.74/robotframework/2.png" alt="2"><br><br><img src="http://149.248.3.74/robotframework/3.png" alt="3"><br></li>
<li><strong>创建测试用例</strong><br><br><img src="http://149.248.3.74/robotframework/4.png" alt="4"><br><br>4.<strong>导入需要用到的库</strong><br><br><img src="http://149.248.3.74/robotframework/5.png" alt="5"><br>5.<strong>f5查看关键词</strong><br><br><img src="http://149.248.3.74/robotframework/6.png" alt="6"> </li>
<li><strong>怎么写测试用例</strong>  蓝色部分为关键字，可以ctr+shift+空格提示补全，如果某个cell显示红色，表示必填选项没有填写。主要流程：打开了浏览器–找到输入框输入”测试”–点击提交–等待2s–截屏并取名到当前目录(library需要导入Sreenshot包)–关闭浏览器–设置变量–调用并打印变量<br><br><img src="http://149.248.3.74/robotframework/7.png" alt="7"><br>7.<strong>脚本形式</strong> <br><br><img src="http://149.248.3.74/robotframework/8.png" alt="8"><br><br>8.<strong>执行过程</strong> <br><br><img src="http://149.248.3.74/robotframework/9.png" alt="9"><br><br>9.<strong>生成目录</strong><br><br><img src="http://149.248.3.74/robotframework/10.png" alt="10"></li>
</ol>
<h2 id="3-快捷键"><a href="#3-快捷键" class="headerlink" title="3.快捷键"></a>3.快捷键</h2><ul>
<li>重命名——》F2</li>
<li>搜索关键字——》F5</li>
<li>执行用例——》F8</li>
<li>创建新工程——》ctrl+n</li>
<li>创建新测试套——》ctrl+shift+f</li>
<li>创建新用例——》ctrl+shift+t</li>
<li>创建新关键字——》ctrl+shift+k</li>
<li>向上移动用例——》ctrl+↑</li>
<li>向下移动用例——》ctrl+↓</li>
<li>显示关键字信息——》 ctrl+鼠标悬浮（鼠标悬浮于关键字上</li>
<li>自动补全关键字——》ctrl+shift+空格</li>
<li>删除行——》ctrl+d</li>
<li>删除单元格——》ctrl+shift+d</li>
<li>插入单元格——》ctrl+shift+i</li>
<li>插入行——》ctrl+i</li>
<li>屏蔽代码——》ctrl+#</li>
<li>取消屏蔽——》ctrl+$</li>
<li>保存整个工程——》ctrl+shit+s</li>
<li>局部保存，保存鼠标点击的部分——》ctrl+s</li>
<li>查看log——》ctrl+L</li>
<li>查看report——》ctrl+r</li>
</ul>
<h2 id="4-其他支持"><a href="#4-其他支持" class="headerlink" title="4.其他支持"></a>4.其他支持</h2><ol>
<li>支持生产HTML类型文件</li>
<li>支持自定义全局变量和变量</li>
<li>支持选择不同的执行方式：pybot、robot、jybot等等</li>
<li>支持自定义关封装键字 <strong>TestLib</strong></li>
<li>Suite Teardown：每个Test Suite结束的时候执行的动作，用法同测试用例中的关键字</li>
<li>Test Setup：每个Test Case启动时执行的动作，用法同测试用例中的关键字。如果在某个具体的Test case中指定了Setup则执行case里的setup而不执行setting里的Test Setup</li>
<li>Test Teardown：每个Test Case结束的时候执行的动作，用法同测试用例中的关键字。同样case里的Teardown会将setting里Test Teardown覆写。</li>
<li>Test Timeout：用例超时时间，超过该时间还未执行完毕的用例将被强制退出</li>
<li>Tags：Tags作为用例的标记，在robot中是非常常用的。在setting中可配置Force Tags和Default Tags，也可在用例中配置Tag，Tag的作用在后面描述</li>
<li>Library：指定TestLib，系统自带的或者已经安装的TestLib可直接输入名字，自己编写的TestLib就需要加入路径，相对路径绝对路径均可，相对的是该html文件的路径</li>
<li>Resource：引入一个资源文件。通常一份比较好的robot用例中包含就是跟该用例相关的关键字，用例和一些基本配置等等，如果需要用到很多公共的模块，公共的关键字，这些公共资源通常会编辑成一个独立的html，这样业务相关的html便可引用</li>
<li>支持if和for循环</li>
<li>支持自定义脚本编写</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/18/robotframework学习/" data-id="cjtoi9xc90009kghz7h7s5ydl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/robotframework/">robotframework</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-Python虚拟环境和Docker虚拟化技术" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/12/Python虚拟环境和Docker虚拟化技术/" class="article-date">
  <time class="post-time" datetime="2019-03-12T13:49:12.000Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">12</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/12/Python虚拟环境和Docker虚拟化技术/">Python虚拟环境和Docker虚拟化技术</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、Python虚拟环境搭建"><a href="#一、Python虚拟环境搭建" class="headerlink" title="一、Python虚拟环境搭建"></a>一、Python虚拟环境搭建</h2><p>注意： <strong><em>pip freeze &gt; requirements.txt</em></strong>将环境里的依赖包写入文件，<strong><em>pip install -r requirements.txt</em></strong>将文件里的依赖包统一安装<br>确保部署环境包版本一致</p>
<h3 id="1-virtualenv"><a href="#1-virtualenv" class="headerlink" title="1.virtualenv"></a>1.virtualenv</h3><h4 id="window下搭建"><a href="#window下搭建" class="headerlink" title="window下搭建"></a>window下搭建</h4><ul>
<li>安装python环境，将bin文件夹加入到系统环境变量，确保命令行下能显示pip版本 <code>pip -V</code></li>
<li>安装virtualenv: <br><br><img src="http://149.248.3.74/bg/3.12/%e5%ae%89%e8%a3%85virtualenv.jpg" alt="安装"></li>
<li>查看是否安装成功: <code>virtualenv --version</code><br><br><img src="http://149.248.3.74/bg/3.12/1552400124.png" alt="1552400124"></li>
<li><p>创建第一个虚拟环境：</p>
<ul>
<li>切换到需要的目录下</li>
<li>执行创建命令 <code>virtualenv DemEnv</code></li>
<li>指定目录下生成虚拟环境目录<br><img src="http://149.248.3.74/bg/3.12/1552400421.png" alt="1552400421"></li>
</ul>
</li>
<li><p>进入虚拟环境:</p>
<ul>
<li>进入Scripts文件夹命令行执行<code>activate.bat</code>文件进入虚拟环境</li>
<li>有图可见pip list是干净的，没有太多库</li>
<li>至此就可以安装需要在开发项目用到的库了如: <code>pip install -U django</code>来开发单独的django项目</li>
<li>注意进入虚拟环境可以看到前面括号的内容</li>
<li>退出虚拟环境只需要命令行执行<code>deactivate.bat</code> 注意退出后使用的环境是系统环境</li>
</ul>
</li>
</ul>
<p><img src="http://149.248.3.74/bg/3.12/1552400853.png" alt="1552400853"></p>
<h4 id="ubuntu16-04下搭建"><a href="#ubuntu16-04下搭建" class="headerlink" title="ubuntu16.04下搭建"></a>ubuntu16.04下搭建</h4><h4 id="类似于window"><a href="#类似于window" class="headerlink" title="类似于window"></a>类似于window</h4><p><img src="http://149.248.3.74/bg/3.12/1552402101.png" alt="1552402101"></p>
<h2 id="另外还有开发requests库大神的另一库Pipenv也是一类环境搭建-https-www-jianshu-com-p-00af447f0005"><a href="#另外还有开发requests库大神的另一库Pipenv也是一类环境搭建-https-www-jianshu-com-p-00af447f0005" class="headerlink" title="另外还有开发requests库大神的另一库Pipenv也是一类环境搭建 https://www.jianshu.com/p/00af447f0005"></a>另外还有开发requests库大神的另一库Pipenv也是一类环境搭建 <a href="https://www.jianshu.com/p/00af447f0005" target="_blank" rel="noopener">https://www.jianshu.com/p/00af447f0005</a></h2><h2 id="一、Docker安装配置"><a href="#一、Docker安装配置" class="headerlink" title="一、Docker安装配置"></a>一、Docker安装配置</h2><h4 id="1-docker支持以下版本"><a href="#1-docker支持以下版本" class="headerlink" title="1.docker支持以下版本"></a>1.docker支持以下版本</h4><ul>
<li>Ubuntu Xenial 16.04[LTS] </li>
<li>Ubuntu Trusty 14.04[LTS]</li>
<li>Ubuntu Precise 12.04[LTS]</li>
</ul>
<h4 id="2-内核版本"><a href="#2-内核版本" class="headerlink" title="2.内核版本"></a>2.内核版本</h4><ul>
<li>Docker需要64位操作系统，kernel版本需要3.10以上 查看系统内核版本 <code>uname -r</code></li>
</ul>
<h4 id="3-安装方式-ubuntu16-04"><a href="#3-安装方式-ubuntu16-04" class="headerlink" title="3.安装方式 ubuntu16.04"></a>3.安装方式 ubuntu16.04</h4><ul>
<li>安装之前先卸载旧版本: <code>sudo apt-get remove docker docker-engine dockre.io containerd runc</code></li>
<li><p>安装方法一：使用脚本安装</p>
<ul>
<li><code>sudo apt install curl</code></li>
<li><code>curl -fsSL get.docker.com -o get-docker.sh</code></li>
<li><code>sudo sh get-docker.sh --mirror Aliyun</code></li>
<li>至此所有工作准备好，Docker CE 的Edge版本也安装在系统中</li>
</ul>
</li>
<li><p>安装方法二：使用APT安装</p>
<ul>
<li>由于 apt 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。<br>`sudo apt-get install <pre><code>apt-transport-https 
ca-certificates 
curl 
software-properties-common`
</code></pre></li>
<li>使用国内源：需要添加软件源的 GPG 密钥。<br><br><code>curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</code><br><code>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code></li>
<li>向souece.list添加docke软件源<br><br><br><code>sudo add-apt-repository 
  &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu $(lsb_release -cs) 
  stable&quot;</code><br><br><strong>以上命令会添加稳定版本的 Docker CE APT 镜像源，如果需要测试或每日构建版本的 Docker CE 请将 stable 改为 test 或者 nightly</strong></li>
<li>安装Docker CE<br><code>sudo apt-get update</code>   <code>sudo apt-get install docker-ce</code></li>
<li>参考<a href="https://yeasy.gitbooks.io/docker_practice/install/ubuntu.html" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/install/ubuntu=.html</a></li>
</ul>
</li>
<li>启动Docker CE<ul>
<li><code>sudo systemctl enable docker</code> ,<code>sudo systemctl start docker</code></li>
<li>ubuntu14.04使用  <code>sudo service docker start</code>启动<h4 id="4-建立-docker-用户组"><a href="#4-建立-docker-用户组" class="headerlink" title="4.建立 docker 用户组"></a>4.建立 docker 用户组</h4></li>
</ul>
</li>
<li>默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。</li>
<li>建立docker组：<code>sudo groupadd docker</code></li>
<li>当前用户加入docker组：<code>sudo usermod -aG docker $USER</code><h4 id="5-测试docker是否安装正确"><a href="#5-测试docker是否安装正确" class="headerlink" title="5.测试docker是否安装正确"></a>5.测试docker是否安装正确</h4></li>
<li><code>docker run hello-world</code><h4 id="6-镜像加速"><a href="#6-镜像加速" class="headerlink" title="6.镜像加速"></a>6.镜像加速</h4></li>
<li><a href="https://registry.docker-cn.com" target="_blank" rel="noopener">Dokcer官方中国镜像地址</a></li>
<li><a href="https://cr.console.aliyun.com/cn-hangzhou/mirrors" target="_blank" rel="noopener">阿里云加速器</a></li>
<li><a href="[https://kirk-enterprise.github.io/hub-docs/#/user-guide/mirror">七牛云加速器</a></li>
<li><p>添加：对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件<br><br> <strong>注意保证json规范</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https://registry.docker-cn.com&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启服务：<code>sudo systemctl daemon-reload</code> <code>sudo systemctl restart docker</code></p>
</li>
<li>检查加速器是否生效：<code>docker info</code>出现如下：<br><br><br><code>Registry Mirrors:
https://registry.docker-cn.com/</code><h4 id="7-下载运行"><a href="#7-下载运行" class="headerlink" title="7.下载运行"></a>7.下载运行</h4></li>
<li>默认下载地址  Docker Hub</li>
<li>下载 <code>docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</code><ul>
<li>Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub。<br>仓库名：如之前所说，这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像</li>
</ul>
</li>
<li>运行某个镜像：<br>`<br>docker run -it –rm \<pre><code>ubuntu:18.04 \
bash
</code></pre>`</li>
<li>-it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。<br>–rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 –rm 可以避免浪费空间。<br>ubuntu:18.04：这是指用 ubuntu:18.04 镜像为基础来启动容器。<br>bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash</li>
<li>一般的命令提示可以 <code>docker command --help</code> 来查看帮助使用<h4 id="8-列出与删除"><a href="#8-列出与删除" class="headerlink" title="8.列出与删除"></a>8.列出与删除</h4></li>
<li>列出：<code>docker image ls</code></li>
<li>便捷的查看镜像、容器、数据卷所占用的空间：<code>docker system df</code></li>
<li>虚悬镜像(dangling image)：镜像既没有仓库名，也没有标签，均为 <none>，可以使用<code>docker image ls -f dangling=true</code>列出 ， 使用<code>docker image prune</code>删除</none></li>
<li>中间层镜像查看：<code>docker image ls -a</code></li>
<li>支持查询过滤：<code>docker image ls -f since=ubuntu</code>表示查询该镜像创建以来的所有镜像。其他的过滤规则：before、label。。。</li>
<li>安装id列出：<code>docker image ls -q</code></li>
<li>go模板语法：<code>docker image ls --format &quot;: &quot;</code></li>
<li>删除:<code>docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</code><br><br><em>其中，&lt;镜像&gt; 可以是 镜像短 ID、镜像长 ID、镜像名 或者 镜像摘要</em></li>
<li>显示镜像摘要：<code>docker image ls --digests</code></li>
<li>所以并非所有的 docker image rm 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已</li>
<li>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为</li>
<li>命令的配合使用：如：<code>docker image rm $(docker image ls -q redis)</code><h4 id="9-利用-commit-理解镜像构成"><a href="#9-利用-commit-理解镜像构成" class="headerlink" title="9.利用 commit 理解镜像构成"></a>9.利用 commit 理解镜像构成</h4></li>
<li>docker commit 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 docker commit 定制镜像，定制镜像应该使用 Dockerfile 来完成</li>
<li>镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层<br></li>
<li><code>docker run --name webserver -d -p 80:80 nginx</code> 这条命令会用 nginx 镜像启动一个容器，命名为 webserver，并且映射了 80 端口，这样我们可以用浏览器去访问这个 nginx 服务器<br><strong>不建议使用commit来提交在原有镜像基础上构造出来的新的镜像，而是用Dockerfile来build来构建</strong><h4 id="10-使用Dockerfile定制自己的镜像"><a href="#10-使用Dockerfile定制自己的镜像" class="headerlink" title="10.使用Dockerfile定制自己的镜像"></a>10.使用Dockerfile定制自己的镜像</h4></li>
<li>大概就是通过一个类似写一个”脚本”(dockerfile)来通过已有容器上创建或者定制新的镜像，并且保存记录</li>
<li>准备：<ul>
<li>当前环境下创建空目录 <code>mkdir nginx_dockerfile</code></li>
<li>进入目录 <code>nginx_dockerfile</code></li>
<li>创建文件 <code>touch Dockerfile</code>这一行必须一模一样，大写</li>
<li>编辑 <code>vim Dockerfile</code> 可以按照Dockerfile的 “语法来写”(FROM、RUN…)<ul>
<li>FROM: 必不可少的命令，从某个镜像作为基。如 <code>FROM &lt;image_name&gt;</code> ，或者 <code>FROM &lt;image_name&gt;:&lt;tag&gt;.</code> 如果不加tag，默认为latest。先从本地镜像仓库去搜索基镜像，如过本地没有，在去网上docker registry去寻找。</li>
<li>MAINTAINER：标明该Dockerfile作者及联系方式，可忽略不写</li>
<li>RUN：建立新的镜像时，可以执行在系统里的命令，如安装特定的软件以及设置环境变量</li>
<li>ENV：设置系统环境变量（注意：写在/etc/profile里的命令在dockerfile这里会不生效，所以为改成ENV的方式）</li>
<li>开放容器内的端口，但不和宿主机进行映射。方便在宿主机上进行开发测试。（如需映射到宿主机端口，可在运行容器时使用 -p host_port:container_port）</li>
<li>CMD：设置执行的命令，经常用于容器启动时指定的某个操作。如执行自定义脚本服务，或者是执行系统命令。CMD 只能存在一条，如在Dockerfile中有多条CMD的话，只有最后一条CMD生效</li>
<li>。。。。。。</li>
</ul>
</li>
</ul>
</li>
<li>创建镜像：在当前目录下执行<code>docker build -t new_image_name .</code>，注意后面的<code>.</code>表示当前目录，因为当前工作环境就在这个目录下，也可以指定Dockerfile所在的目录</li>
<li>可以在已经创建的镜像上创建新的容器：<code>docker run -d -it --name new_image_name2 new_image_name</code></li>
</ul>
<h4 id="11-容器操作"><a href="#11-容器操作" class="headerlink" title="11.容器操作"></a>11.容器操作</h4><ul>
<li>创建容器：<code>docker run -dit ubuntu</code> ，d参数：守护运行(后台),i参数：分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上，-i 则让容器的标准输入保持打开。</li>
<li>列出容器：<code>docker container ls</code></li>
<li>进入容器1：<code>docker attach ID</code>  退出：<code>exit</code>容器终止</li>
<li>进入容器2：<code>docker exec -it ID bash</code> 退出： <code>exit</code> 容器不会终止  帮助：<code>docker exec --help</code></li>
<li>启动已经停止的容器： <code>docker container start</code></li>
<li>导出容器：<code>docker export ID &gt; name.tar</code></li>
<li>导入容器：<code>cat name.tar | docker import - test/ubuntu:v10</code>。  也可以通过url或者路径导入：<code>docker import http://example.com/exampleimage.tgz example/imagerepo</code></li>
<li>删除终止状态容器：<code>docker container rm  trusting_newton</code> 。删除运行中的容器：加 -f 参数</li>
<li>清理所有终止状态的容器： <code>docker container prune</code><h4 id="12-访问远程仓库"><a href="#12-访问远程仓库" class="headerlink" title="12.访问远程仓库"></a>12.访问远程仓库</h4></li>
<li><a href="https://hub.docker.com/" target="_blank" rel="noopener">注册</a></li>
<li>宿主机登录: <code>docker login</code></li>
<li>宿主机退出登录：<code>logout</code></li>
<li>搜索： <code>docker search YouImageName</code></li>
</ul>
<hr>
<p>2019/3/17 15:53:53 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/12/Python虚拟环境和Docker虚拟化技术/" data-id="cjtoi9xc70006kghzlfwamh1q" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/环境/">环境</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="title-Selenium一些API整理" class="wow slideInRight article article-type-title" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/11/Selenium一些API整理/" class="article-date">
  <time class="post-time" datetime="2019-03-11T13:32:09.000Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">11</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/11/Selenium一些API整理/">Selenium一些API整理</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/自动化测试/">自动化测试</a>
  </div>

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="关于一些前提准备条件和说明"><a href="#关于一些前提准备条件和说明" class="headerlink" title="关于一些前提准备条件和说明"></a>关于一些前提准备条件和说明</h3><ul>
<li><p>支持Chrome、Firefox、IE、Phantomjs等浏览器</p>
</li>
<li><p>需要下载对应浏览器的webDriver,其中Phantomjs无头浏览器不需要下载webdriver，其优点是不需要加载网页，速度比较快，Firefox有些条件下可以不用driver</p>
</li>
<li>这里引入常见的driver下载地址，<a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">Chrome webdriver下载地址一…</a><br>为防止官方下载地址失效，这里备份到文件服务器70.0~73.0 Chrome版本(同一大版本，基本兼容小版本) <a href="http://149.248.3.74/WebDriver/" target="_blank" rel="noopener">Chrome webDrive下载地址二…</a><br>火狐浏览器<a href="https://github.com/mozilla/geckodriver/releases/" target="_blank" rel="noopener">Firefox WebDriver</a> IE浏览器<a href="http://selenium-release.storage.googleapis.com/index.html" target="_blank" rel="noopener">IE webDriver</a></li>
<li>方法1：webDriver需要放在浏览器安装目录下(执行文件同级目录，并且加入环境变量)。 方法2：直接将webDriver拷贝到脚本同级目录下执行。方法3：<br>导入os包，将脚本执行目录切换到webDriver的目录下(os.chdir(path))</li>
<li>Phantomjs浏览器安装，<a href="http://phantomjs.org/download.html" target="_blank" rel="noopener">下载地址</a>，win下解压zip包，将bin目录加到系统环境变量，在命令行输入phantomjs，既可看到。<br><a href="http://javascript.ruanyifeng.com/tool/phantomjs.html" target="_blank" rel="noopener">Phantomjs使用教程</a></li>
<li>安装selenium，基于Python的selenium安装，<code>pip install selenium</code>,查看版本 <code>pip show selenium</code></li>
<li>最新Firefox和Seleniu兼容有问题，相关解决方案：<ul>
<li>安装旧版本Firefox47，同时安装插件firebug和firepath(写爬虫很有用)，这里需要关闭火狐浏览器的自动更新功能(百度查找方法)，<br><a href="http://ftp.mozilla.org/pub/firefox/releases/" target="_blank" rel="noopener">Firefox下载地址</a></li>
<li>Selenium3以前的版本，使用firefox不需要webdriver，3.x后的版本需要安装webdriver，下载地址上有说明</li>
</ul>
</li>
<li><p>结合的测试框架(基于Python):</p>
<ul>
<li><p>unittest: 一般python环境自带，示例代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import unittest</span><br><span class="line"></span><br><span class="line">def fun(x):</span><br><span class="line">    return x + 1</span><br><span class="line"></span><br><span class="line">class MyTest(unittest.TestCase):</span><br><span class="line">    def test(self):</span><br><span class="line">        self.assertEqual(fun(3), 4)</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/baby_hua/article/details/80571109" target="_blank" rel="noopener">使用说明详细</a><br><br><br>常见断言：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#msg：判断不成立时需要反馈的字符串</span><br><span class="line">assertEqual(self, first, second, msg=None)</span><br><span class="line">--判断两个参数相等：first == second</span><br><span class="line">assertNotEqual(self, first, second, msg=None)</span><br><span class="line">--判断两个参数不相等：first ！= second</span><br><span class="line">assertIn(self, member, container, msg=None)</span><br><span class="line">--判断是字符串是否包含：member in container</span><br><span class="line">assertNotIn(self, member, container, msg=None)</span><br><span class="line">--判断是字符串是否不包含：member not in container</span><br><span class="line">assertTrue(self, expr, msg=None)</span><br><span class="line">--判断是否为真：expr is True</span><br><span class="line">assertFalse(self, expr, msg=None)</span><br><span class="line">--判断是否为假：expr is False</span><br><span class="line">assertIsNone(self, obj, msg=None)</span><br><span class="line">--判断是否为None：obj is None</span><br><span class="line">assertIsNotNone(self, obj, msg=None)</span><br><span class="line">--判断是否不为None：obj is not None</span><br></pre></td></tr></table></figure>
</li>
<li><p>unittest2: unittest升级版，详细文档 <a href="https://pypi.org/project/unittest2/" target="_blank" rel="noopener">https://pypi.org/project/unittest2/</a></p>
</li>
<li>py.test:<br><a href="https://www.jianshu.com/p/6e6275018b7e" target="_blank" rel="noopener">Selenium + Pytest + Allure</a><br><a href="https://www.jianshu.com/p/15b319ff6cd5?mType=Group" target="_blank" rel="noopener">pytest+allure2+jenkins</a><br><a href="https://www.cnblogs.com/davieyang/p/10095980.html" target="_blank" rel="noopener">Python&amp;Selenium&amp;pytest借助allure生成自动化测试报告</a></li>
<li>Nose: Nose是对unittest的扩展，使得python的测试更加简单。nose自动发现测试代码并执行，nose提供了大量的插件，比如测试输出的xUnitcompatible，覆盖报表等等<br><br><br>nose的详细文档：<a href="https://nose.readthedocs.org/en/latest/" target="_blank" rel="noopener">https://nose.readthedocs.org/en/latest/</a><br>注意：nose本身是支持python3的，但是很多它的插件不支持</li>
<li>tox:<br>最大的特色，是自动最测试环境的管理以及使用多个解析器配置进行测试。<br>tox的详细文档：<a href="http://testrun.org/tox/latest/" target="_blank" rel="noopener">http://testrun.org/tox/latest/</a></li>
</ul>
</li>
</ul>
<h3 id="Selenium介绍，来源-selenium中文文档"><a href="#Selenium介绍，来源-selenium中文文档" class="headerlink" title="Selenium介绍，来源: selenium中文文档"></a>Selenium介绍，来源: <a href="https://selenium-python-zh.readthedocs.io/en/latest/navigating.html" target="_blank" rel="noopener">selenium中文文档</a></h3><h4 id="注意！！！如果使用远程webDriver，需要安装selenium服务器："><a href="#注意！！！如果使用远程webDriver，需要安装selenium服务器：" class="headerlink" title="注意！！！如果使用远程webDriver，需要安装selenium服务器："></a>注意！！！如果使用远程webDriver，需要安装selenium服务器：</h4><ol>
<li>需要Java Runtime Environment (JRE) 1.6或者更高的版本是推荐的运行环境。</li>
<li>server下载地址：<a href="https://www.seleniumhq.org/download/" target="_blank" rel="noopener">下载地址1</a>,我的服务器<a href="http://149.248.3.74/seleniumServer/" target="_blank" rel="noopener">下载地址2</a></li>
<li>针对以及装好java环境和下载好了server的win系统，命令行运行:<code>java -jar selenium-server-standalone-2.x.x.jar</code>(这里我没有成功，可能是java环境没装好,什么时候用得到远程再来折腾)<br><br> linux下<code>/path/to/java -jar /path/to/selenium-server-standalone-2.x.x.jar</code><h4 id="1-打开一个页面"><a href="#1-打开一个页面" class="headerlink" title="1. 打开一个页面"></a>1. 打开一个页面</h4><ul>
<li>导入selenium包后绑定对应浏览器的webdriver<br><br><code>driver.get(&quot;http://www.zhihu.com&quot;)</code></li>
<li>页面元素查找<ul>
<li><code>find_element_by_name()</code></li>
<li><code>find_element_by_class_name()</code></li>
<li><code>find_element_by_xpath()</code>这种定位方式参考 <a href="http://www.w3school.com.cn/xpath/xpath_syntax.asp" target="_blank" rel="noopener">xpath语法</a>一般浏览器自带的源代码检查可以copy xpath格式</li>
<li><code>find_element_by_css_selector()</code>参考CSS语法 <a href="https://blog.csdn.net/qq_33472765/article/details/80740097" target="_blank" rel="noopener">selector语法</a>一般浏览器自带的源代码检查可以copy selector格式</li>
<li><code>find_element_by_tag_name ()</code> 标签名定位</li>
<li><code>find_element_by_link_text()</code> <code>find_element_by_partial_link_text()</code>  二者都是点位超链接，第一种需要定位完整的超链接字段，第二种可以匹配部分超链接字段</li>
<li><code>find_element(By.ID,&quot;kw&quot;)</code></li>
<li><code>find_element(By.NAME,&quot;wd&quot;)</code></li>
<li><code>find_element(By.CLASS_NAME,&quot;s_ipt&quot;)</code></li>
<li><code>find_element(By.TAG_NAME,&quot;input&quot;)</code></li>
<li><code>find_element(By.LINK_TEXT,u&quot;新闻&quot;)</code></li>
<li><code>find_element(By.PARTIAL_LINK_TEXT,u&quot;新&quot;)</code></li>
<li><code>find_element(By.XPATH,&quot;//*[@class=&#39;bg s_btn&#39;]&quot;)</code></li>
<li><code>find_element(By.CSS_SELECTOR,&quot;span.bg s_btn_wr&gt;input#su&quot;)</code></li>
<li><code>find_elements_by_id()</code></li>
<li><code>find_elements_by_name()</code></li>
<li><code>find_elements_by_class_name()</code></li>
<li><code>find_elements_by_tag_name()</code></li>
<li><code>find_elements_by_link_text()</code></li>
<li><code>find_elements_by_partial_link_text()</code></li>
<li><code>find_elements_by_xpath()</code></li>
<li><code>find_elements_by_css_selector()</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>页面交互<ul>
<li><code>element.send_keys(&quot;some text&quot;)</code>发送关键词到input</li>
<li><code>element.send_keys(&quot; and some&quot;, Keys.ARROW_DOWN)</code>自带的键盘模拟类执行enter</li>
<li><code>.click</code> 选择</li>
<li><code>.submit</code>提交表单</li>
</ul>
</li>
</ul>
<hr>
<h3 id="更多关于selenium-API参考-中文文档"><a href="#更多关于selenium-API参考-中文文档" class="headerlink" title="更多关于selenium API参考 中文文档"></a>更多关于selenium API参考 <a href="https://selenium-python-zh.readthedocs.io/en/latest/navigating.html#id5" target="_blank" rel="noopener">中文文档</a></h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/11/Selenium一些API整理/" data-id="cjtoi9xc30004kghzl9gj58tu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Selenium/">Selenium</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="title-各种协议" class="wow slideInRight article article-type-title" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/11/各种协议/" class="article-date">
  <time class="post-time" datetime="2019-03-11T12:50:06.000Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">11</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/11/各种协议/">各种协议</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/协议/">协议</a>
  </div>

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>TCP是面向连接的通讯协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接的所以只能用于端到端的通讯。<br>TCP提供的是一种可靠地数据流服务，采用带重传的”肯定确定”技术来实现传输的可靠性。TCP还采用一种称为”窗口滑动”的方式进行流量控制。<br>所谓窗口实际表示接收能力，用以限制发送方的发送速度。如果IP数据包中已经有封装好的数据包，那么IP将把他们向上传送到TCP层。TCP将包排序并进行错误检查，<br>同时实现虚电路之间的连接。TCP数据包中包括序号和确认，所有未按照顺序收到的包可以被排序，而损坏的包可以重传。TCP将他的信息送到更高层的应用程序，例如TelNet<br>的服务程序和客户程序，应用程序轮流将信息送回TCP层，TCP层便将他们向下传送到IP层，设备驱动程序和物理介质，最后到接收方。<br>面向连接服务需要高度的可靠性，所以他们使用了TCP。DNS在某些情况下使用TCP(发送和接收域名数据库)，但使用UDP传送有关单个主机的信息。</p>
<h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p>UDP是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。<br>UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编码验证。<br>UDP与TCP位于同一层，但他不管数据包的顺序、错误或者重发。因此，UDP不被应用于那些使用虚电路的面向连接的服务，<br>UDP主要用于那些面向查询、应答的服务，例如NFS。相对于FTP和Telnet，这些服务需要交换的信息量较小。使用UDP的服务包括NTP(网络时间协议)和DNS(DNS也使用TCP)。<br>欺骗UDP包比欺骗TCP包更容易，因为UDP没有建立初始化连接，也就是与UDP相关的服务面领着更大的危险。</p>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>支持C/S</li>
<li>简单快速</li>
<li>灵活</li>
<li>无状态</li>
<li>无连接<h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4></li>
<li>请求行</li>
<li>消息报头</li>
<li>请求正文<h3 id="常见的请求方法"><a href="#常见的请求方法" class="headerlink" title="常见的请求方法"></a>常见的请求方法</h3></li>
<li>GET、POST、HEAD、PUT、</li>
</ul>
<hr>
<p><strong><em>马克马克马克</em></strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/11/各种协议/" data-id="cjtoi9xd3000mkghzzz36aycu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/协议/">协议</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-数据结构" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/11/数据结构/" class="article-date">
  <time class="post-time" datetime="2019-03-11T12:43:34.000Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">11</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/11/数据结构/">数据结构</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据结构/">数据结构</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数据：所有能够输入到计算机中，并且能被计算机处理的符号的集合。</p>
<h4 id="ADT：抽象数据类型"><a href="#ADT：抽象数据类型" class="headerlink" title="ADT：抽象数据类型"></a>ADT：抽象数据类型</h4><h4 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h4><ul>
<li>特征：所有元素属于同一数据类型</li>
<li>有限：数据元素个数是有限的</li>
<li>序列：数据元素由逻辑符号唯一确定，一个线性表中允许有相同值元素</li>
<li>线性表基本运算：<ul>
<li>初始化线性表InitList(&amp;L):构造空的线性表L</li>
<li>销毁线性表DestoryList(&amp;L): 释放线性表L占用的空间</li>
<li>判断线性表是否为空值ListEmpty(L): L为真返回空，否，返回假</li>
<li>求线性表长度ListLength：返回L中元素n</li>
<li>…</li>
</ul>
</li>
<li><p>定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">     ElemType data[MAXSIZE];</span><br><span class="line">     int length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑位序和物理位序正好相差1</p>
</li>
<li>输出型参数 都在前面加上&amp;</li>
<li><p>初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void InitList(SqList *L)&#123;</span><br><span class="line">L=(*SqList)malloc(sizeof(SqList));</span><br><span class="line">L-&gt;length=0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>销毁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vold DestoryList(SqList *L)&#123;&#125;</span><br><span class="line">free(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>是否为空</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool ListEmpty(SqList *L)&#123;</span><br><span class="line"> return(L-&gt;length==0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int ListLength(Sqlist *L)&#123;</span><br><span class="line">return L-&gt;length; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出线性表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void DispList(SqList *L)&#123;</span><br><span class="line">int i=0;</span><br><span class="line">if(L-&gt;length==0) return;</span><br><span class="line">for(i;i&lt;L-&gt;length;i++)&#123;</span><br><span class="line"> printf(&quot;%c&quot;,L-&gt;data[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>1、实现删除顺序表中所有为x的元素</p>
<ul>
<li><p>方法1：利用旧的顺序表里新建顺序表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void Func(SqList *&amp;A,ElemType x)&#123;</span><br><span class="line"> int k=0,i=0;</span><br><span class="line"> for(i;i&lt;A-&gt;length;i++)&#123;</span><br><span class="line"> if(A-&gt;data[i]!=x)&#123;</span><br><span class="line"> A-&gt;data[k]=A-&gt;data[i];</span><br><span class="line"> k++;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> A-&gt;length=k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法2：将不为x的元素迁移K个位置，最后修改A的长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void Func(SqList *&amp;A,ElemType x)&#123;</span><br><span class="line">int k=0,i=0;</span><br><span class="line">while(i&lt;A-&gt;length)&#123;</span><br><span class="line">if(A-&gt;length==x)</span><br><span class="line">    k++;</span><br><span class="line">else</span><br><span class="line">    A-&gt;data[i-k]=A-&gt;data[i];</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A-&gt;length=A-&gt;length-k;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2、实现长度为10的顺序表，以第一个元素为分界线，将小于他的元素移到该基准前面，大于的放在后面。</p>
<ul>
<li>方法1：拿出基准，i从左往右扫描，j从右往左，找到合适的元素交换顺序，直到i=j，将基准放入i=j位置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void move(SqList *&amp;L)&#123;</span><br><span class="line">int i=0,j=L-&gt;length;</span><br><span class="line">ElemType tmp;</span><br><span class="line">ElemType pivot=L-&gt;data[0]);</span><br><span class="line">while(i&lt;j)&#123;</span><br><span class="line">     while(i&lt;j&amp;&amp;L-&gt;data[j]&gt;pivot)</span><br><span class="line">     j--;</span><br><span class="line">     </span><br><span class="line">     while(i&lt;j&amp;&amp;L-&gt;data[i]&lt;=pivot)</span><br><span class="line">     i++;</span><br><span class="line">     if(i&lt;j)&#123;</span><br><span class="line">     tmp=L-&gt;data[i];</span><br><span class="line">     L-&gt;data[i]=L-&gt;data[j];</span><br><span class="line">     L-&gt;data[j]=tmp;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tmp=L-&gt;data[0];</span><br><span class="line">L-&gt;data[0]=L-&gt;data[j];</span><br><span class="line">L-&gt;data[j]=tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="线性表和链表的区别"><a href="#线性表和链表的区别" class="headerlink" title="线性表和链表的区别"></a>线性表和链表的区别</h5><ul>
<li>顺序表具有随机存储的特性，存储密度大，但是插入和删除需要移动大量的数据，初始化分配空间难以确定</li>
<li>链表采用动态分配内存的方法，具有良好的适应性，插入删除只需要修改相关的指针域，不需要移动元素，但是存储密度小，需要有额外的<br>存储空间，指针域，不具有随机存储特性<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3>优点：从任一节点出发可以 找到其前驱节点和后继节点，从任一点出发可以访问其他节点。<h3 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h3></li>
<li>链表没有空指针域</li>
<li><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3></li>
<li>定义：栈是一种只能在同一段插入或删除的线性表，栈只能选取同一个短点进行插入或删除操作(栈顶)，另一端为栈底</li>
<li>后进先出</li>
</ul>
<hr>
<p><strong><em>马克  马克 马克</em></strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/11/数据结构/" data-id="cjtoi9xdl000ykghzm74omci6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>




  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">next &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">YuChou</h1>
    <h2 class="blog-subtitle">Dream of walking the world with techbology</h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives/" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories/" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags/" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="http://149.248.3.74/Photos/titleImage/AF359E06C1819F0FA30D32DA9F0E8EB6.png">
    <h2 class="author">YuChou</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>12</strong><br>文章</div></a>
      <a href="/categories"><div><strong>8</strong><br>分类</div></a>
      <a href="/tags"><div><strong>11</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="https://github.com/mrzhouyu" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>SomeLink</h2>
      
        <a class="hvr-bounce-in" href="https://www.zhihu.com" target="_blank" title="Zhihu">
          Zhihu
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2018 - 2019 YuChou<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a href="https://github.com/ShanaMaid/hexo-theme-shana">Shana</a>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  <link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">
  <script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>



  <link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">
  <script src="/plugin/galmenu/GalMenu.js"></script>
  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/tags" title="" class="menuItem">标签</a>
          
            <a href="/categories" title="" class="menuItem">分类</a>
          
            <a href="/archives" title="" class="menuItem">归档</a>
          
            <a href="/xxxxxxxxx" title="" class="menuItem">xxx</a>
          
            <a href="/xxxxxxx" title="" class="menuItem">xxxx</a>
          
        </div>
        
          <audio id="audio" src="#"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>
<script src="/js/script.js"></script>



  </div>
</body>
</html>