<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Python多进程 | YuChou</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Python多进程使用与总结1.概要​    众所周知，由于GIL锁的存在，Python多线程并不是真正意义上的多线程，不能很好的利用多核CPU，为了充分的利用系统资源，py提供了multiprocessing多进程库，其支持子进程、通信和数据共享、执行不同形式的同步，提供了Process、Queue、Pipe、Lock等组件。[参考]（https://www.cnblogs.com/tkqasn">
<meta name="keywords" content="多进程">
<meta property="og:type" content="article">
<meta property="og:title" content="Python多进程">
<meta property="og:url" content="http://yoursite.com/2019/03/31/Python多进程/index.html">
<meta property="og:site_name" content="YuChou">
<meta property="og:description" content="Python多进程使用与总结1.概要​    众所周知，由于GIL锁的存在，Python多线程并不是真正意义上的多线程，不能很好的利用多核CPU，为了充分的利用系统资源，py提供了multiprocessing多进程库，其支持子进程、通信和数据共享、执行不同形式的同步，提供了Process、Queue、Pipe、Lock等组件。[参考]（https://www.cnblogs.com/tkqasn">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-04-01T14:26:52.559Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python多进程">
<meta name="twitter:description" content="Python多进程使用与总结1.概要​    众所周知，由于GIL锁的存在，Python多线程并不是真正意义上的多线程，不能很好的利用多核CPU，为了充分的利用系统资源，py提供了multiprocessing多进程库，其支持子进程、通信和数据共享、执行不同形式的同步，提供了Process、Queue、Pipe、Lock等组件。[参考]（https://www.cnblogs.com/tkqasn">
  
    <link rel="alternate" href="/atom.xml" title="YuChou" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/plugin/bganimation/bg.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="http://149.248.3.74/Photos/titleImage/AF359E06C1819F0FA30D32DA9F0E8EB6.png">
    <h2 class="author">YuChou</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>15</strong><br>文章</div></a>
      <a href="/categories"><div><strong>10</strong><br>分类</div></a>
      <a href="/tags"><div><strong>15</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives/" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories/" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags/" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main"><article id="post-Python多进程" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/31/Python多进程/" class="article-date">
  <time class="post-time" datetime="2019-03-31T03:03:50.000Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">31</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Python多进程
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Python多进程使用与总结"><a href="#Python多进程使用与总结" class="headerlink" title="Python多进程使用与总结"></a>Python多进程使用与总结</h2><h4 id="1-概要"><a href="#1-概要" class="headerlink" title="1.概要"></a>1.概要</h4><p>​    众所周知，由于GIL锁的存在，Python多线程并不是真正意义上的多线程，不能很好的利用多核CPU，为了充分的利用系统资源，py提供了multiprocessing多进程库，其支持子进程、通信和数据共享、执行不同形式的同步，提供了Process、Queue、Pipe、Lock等组件。[参考]（<a href="https://www.cnblogs.com/tkqasn/p/5701230.html" target="_blank" rel="noopener">https://www.cnblogs.com/tkqasn/p/5701230.html</a>）</p>
<blockquote>
<ul>
<li>在UNIX平台上，当某个进程终结之后，该进程需要被其父进程调用wait，否则进程成为僵尸进程(Zombie)。所以，有必要对每个Process对象调用join()方法 (实际上等同于wait)。对于多线程来说，由于只有一个进程，所以不存在此必要性。</li>
<li>multiprocessing提供了threading包中没有的IPC(比如Pipe和Queue)，效率上更高。应优先考虑Pipe和Queue，避免使用Lock/Event/Semaphore/Condition等同步方式 (因为它们占据的不是用户进程的资源)。</li>
<li>多进程应该避免共享资源。在多线程中，我们可以比较容易地共享资源，比如使用全局变量或者传递参数。在多进程情况下，由于每个进程有自己独立的内存空间，以上方法并不合适。此时我们可以通过共享内存和Manager的方法来共享资源。但这样做提高了程序的复杂度，并因为同步的需要而降低了程序的效率。</li>
<li>Process.PID中保存有PID，如果进程还没有start()，则PID为None。</li>
</ul>
</blockquote>
<p><strong><em>注意：window下启动子进程必须在if <strong>name</strong> == “main”语句后面写相关语句，这个坑踩过</em></strong></p>
<p><strong><em>注意：window下启动子进程必须在if name == “main”语句后面写相关语句，这个坑踩过</em></strong></p>
<h4 id="2-使用实例"><a href="#2-使用实例" class="headerlink" title="2.使用实例"></a>2.使用实例</h4><h5 id="2-1-创建多进程"><a href="#2-1-创建多进程" class="headerlink" title="2.1 创建多进程"></a>2.1 创建多进程</h5><h4 id="方式一：直接使用Process"><a href="#方式一：直接使用Process" class="headerlink" title="方式一：直接使用Process"></a>方式一：直接使用Process</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">out</span><span class="params">(msg)</span>:</span></span><br><span class="line">    s = random.randint(<span class="number">1</span>, <span class="number">3</span>) <span class="comment">#随机延时</span></span><br><span class="line">    time.sleep(s)</span><br><span class="line">    print(<span class="string">"msg:&#123;&#125;  time:&#123;&#125;   pid：&#123;&#125; ppid:&#123;&#125;"</span>.format(msg, time.asctime(time.localtime(time.time())), os.getpid(), os.getppid()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">que</span><span class="params">()</span>:</span></span><br><span class="line">    Queue = queue.Queue()<span class="comment">#创建队列 先进先出</span></span><br><span class="line">    <span class="keyword">for</span> q <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        Queue.put(q)</span><br><span class="line">    <span class="keyword">return</span> Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    Que = que()	</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p = multiprocessing.Process(target=out, args=(Que.get(), ))</span><br><span class="line">        p.start()</span><br><span class="line">        <span class="comment"># p.join() # location1</span></span><br><span class="line">    <span class="comment"># p.join() #location2</span></span><br><span class="line">    print(<span class="string">"我是主进程"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>基本逻辑：创建一个动作函数out() ,增加随机时间的延时，以便查看控制台输出差异，输出msg、当前时间、子进程pid、父进程pid。定义一个队列函数que(),作为生产者，为后面取得输出参数做好准备。p:创建一个进程，p.start()开启一个进程，p.join()阻塞主进程，直到子进程执行完毕.注意：<strong><em>window下启动子进程必须在if name == “main”语句后面写相关语句，这个坑踩过</em></strong>（不知道为什么这个markdown编辑器，双下滑线没有显示，可能是渲染引擎问题），args参数是元组类型，若是只有一个参数，需要加上最后 <code>，</code></p>
</li>
<li><p>location1处和location2处join均注释，主进程在子进程之前执行完毕，控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">我是主进程</span><br><span class="line">msg:2  time:Sun Mar 31 20:45:22 2019   pid：17068 ppid:28044</span><br><span class="line">msg:4  time:Sun Mar 31 20:45:22 2019   pid：25004 ppid:28044</span><br><span class="line">msg:5  time:Sun Mar 31 20:45:22 2019   pid：14576 ppid:28044</span><br><span class="line">msg:7  time:Sun Mar 31 20:45:23 2019   pid：26384 ppid:28044</span><br><span class="line">msg:9  time:Sun Mar 31 20:45:23 2019   pid：3368 ppid:28044</span><br><span class="line">msg:1  time:Sun Mar 31 20:45:23 2019   pid：25052 ppid:28044</span><br><span class="line">msg:3  time:Sun Mar 31 20:45:23 2019   pid：23948 ppid:28044</span><br><span class="line">msg:0  time:Sun Mar 31 20:45:24 2019   pid：13660 ppid:28044</span><br><span class="line">msg:6  time:Sun Mar 31 20:45:24 2019   pid：1052 ppid:28044</span><br><span class="line">msg:8  time:Sun Mar 31 20:45:25 2019   pid：13968 ppid:28044</span><br></pre></td></tr></table></figure>
</li>
<li><p>只有location2处join注释，主进程在子进程之后执行，但是可看出输出顺序是0~9，总的时间特别长，阻塞输出，控制台输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">msg:0  time:Sun Mar 31 20:51:06 2019   pid：11048 ppid:3936</span><br><span class="line">msg:1  time:Sun Mar 31 20:51:09 2019   pid：18504 ppid:3936</span><br><span class="line">msg:2  time:Sun Mar 31 20:51:10 2019   pid：15580 ppid:3936</span><br><span class="line">msg:3  time:Sun Mar 31 20:51:12 2019   pid：25180 ppid:3936</span><br><span class="line">msg:4  time:Sun Mar 31 20:51:15 2019   pid：25912 ppid:3936</span><br><span class="line">msg:5  time:Sun Mar 31 20:51:17 2019   pid：22660 ppid:3936</span><br><span class="line">msg:6  time:Sun Mar 31 20:51:21 2019   pid：13224 ppid:3936</span><br><span class="line">msg:7  time:Sun Mar 31 20:51:23 2019   pid：14204 ppid:3936</span><br><span class="line">msg:8  time:Sun Mar 31 20:51:24 2019   pid：2940 ppid:3936</span><br><span class="line">msg:9  time:Sun Mar 31 20:51:28 2019   pid：9068 ppid:3936</span><br><span class="line">我是主进程</span><br></pre></td></tr></table></figure>
</li>
<li><p>只有location1处join注释，主进程在子进程之后执行，其中很多进程执行时间相同，而且顺序错乱，总时间短，控制台输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">msg:1  time:Sun Mar 31 20:52:04 2019   pid：24448 ppid:13532</span><br><span class="line">msg:5  time:Sun Mar 31 20:52:04 2019   pid：23376 ppid:13532</span><br><span class="line">msg:2  time:Sun Mar 31 20:52:05 2019   pid：22048 ppid:13532</span><br><span class="line">msg:6  time:Sun Mar 31 20:52:05 2019   pid：18968 ppid:13532</span><br><span class="line">msg:7  time:Sun Mar 31 20:52:05 2019   pid：26208 ppid:13532</span><br><span class="line">msg:0  time:Sun Mar 31 20:52:06 2019   pid：15948 ppid:13532</span><br><span class="line">msg:3  time:Sun Mar 31 20:52:06 2019   pid：26724 ppid:13532</span><br><span class="line">msg:4  time:Sun Mar 31 20:52:06 2019   pid：13220 ppid:13532</span><br><span class="line">msg:8  time:Sun Mar 31 20:52:06 2019   pid：24384 ppid:13532</span><br><span class="line">msg:9  time:Sun Mar 31 20:52:06 2019   pid：4392 ppid:13532</span><br><span class="line">我是主进程</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="方式二：重写run-方法"><a href="#方式二：重写run-方法" class="headerlink" title="方式二：重写run()方法"></a>方式二：重写run()方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myprocess</span><span class="params">(Process)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        super(Myprocess, self).__init__()<span class="comment"># 或者Process.__init__(self)</span></span><br><span class="line">        self.msg = msg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        s = random.randint(<span class="number">1</span>, <span class="number">3</span>)  <span class="comment"># 随机延时</span></span><br><span class="line">        time.sleep(s)</span><br><span class="line">        print(<span class="string">"msg:&#123;&#125;  time:&#123;&#125;   pid：&#123;&#125; ppid:&#123;&#125;"</span>.format(self.msg, time.asctime(time.localtime(time.time())), os.getpid(),</span><br><span class="line">                                                        os.getppid()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">que</span><span class="params">()</span>:</span></span><br><span class="line">    Queue = queue.Queue()  <span class="comment"># 创建队列 先进先出</span></span><br><span class="line">    <span class="keyword">for</span> q <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        Queue.put(q)</span><br><span class="line">    <span class="keyword">return</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    Que = que()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p = Myprocess(msg=Que.get())</span><br><span class="line">        p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">"我是主进程"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>基本逻辑：定义一个子类，继承Process类，因为不想完全重写父类的<strong>init</strong>，所以这里使用super()或者Process.<strong>init</strong>(self)将子类参数传递给父类。其中run()方法为动作函数，这个也是来自父类的方法，这里因为准备完全重写父类的方法，所以不用super()方法，也可以使用super(Myprocess, self).run()来避免完全重写父类方法。函数功能run()对应前面的out()函数功能。</p>
</li>
<li><blockquote>
<p><strong>super()</strong> 函数是用于调用父类(超类)的一个方法。super 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题。MRO 就是类的方法解析顺序表, 其实也就是继承父类方法时的顺序表</p>
</blockquote>
</li>
<li><p>没弄明白为什么这个主进程没有阻塞，控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">msg:2  time:Sun Mar 31 21:40:37 2019   pid：4396 ppid:23176</span><br><span class="line">msg:3  time:Sun Mar 31 21:40:37 2019   pid：18640 ppid:23176</span><br><span class="line">msg:8  time:Sun Mar 31 21:40:37 2019   pid：13612 ppid:23176</span><br><span class="line">msg:9  time:Sun Mar 31 21:40:37 2019   pid：13196 ppid:23176</span><br><span class="line">我是主进程</span><br><span class="line">msg:1  time:Sun Mar 31 21:40:38 2019   pid：16324 ppid:23176</span><br><span class="line">msg:4  time:Sun Mar 31 21:40:38 2019   pid：14560 ppid:23176</span><br><span class="line">msg:5  time:Sun Mar 31 21:40:38 2019   pid：6376 ppid:23176</span><br><span class="line">msg:6  time:Sun Mar 31 21:40:38 2019   pid：26088 ppid:23176</span><br><span class="line">msg:7  time:Sun Mar 31 21:40:38 2019   pid：23056 ppid:23176</span><br><span class="line">msg:0  time:Sun Mar 31 21:40:39 2019   pid：14724 ppid:23176</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="2-2-Process类"><a href="#2-2-Process类" class="headerlink" title="2.2 Process类"></a>2.2 Process类</h5><hr>
<blockquote>
<ul>
<li><p><strong>构造方法：</strong></p>
<p>Process([group [, target [, name [, args [, kwargs]]]]])</p>
<p>　　group: 线程组，目前还没有实现，库引用中提示必须是None；<br>　　target: 要执行的方法；<br>　　name: 进程名；<br>　　args/kwargs: 要传入方法的参数。。</p>
</li>
<li><p><strong>实例方法：</strong></p>
<p>　　is_alive()：返回进程是否在运行。</p>
<p>　　join([timeout])：阻塞当前上下文环境的进程程，直到调用此方法的进程终止或到达指定的timeout（可选参数）。</p>
<p>　　start()：进程准备就绪，等待CPU调度</p>
<p>　　run()：strat()调用run方法，如果实例进程时未制定传入target，这star执行t默认run()方法。</p>
<p>　　terminate()：不管任务是否完成，立即停止工作进程，但是子进程如果存在没完成，就会变成僵尸进程</p>
</li>
<li><p><strong>属性：</strong></p>
<p>　　authkey</p>
<p>　　daemon：和线程的setDeamon功能一样，守护进程，父进程死了子进程也死了</p>
<p>　　exitcode(进程在运行时为None、如果为–N，表示被信号N结束）</p>
<p>　　name：进程名字。</p>
<p>　　pid：进程号。</p>
</li>
</ul>
</blockquote>
<ul>
<li>is_alive()、p.name、p.pid 、p.exitcode:实例：下面代码用的是重写的Myprocess，直接使用Process也是一样的</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">..........</span><br><span class="line">p = Myprocess(msg=<span class="number">10086</span>)</span><br><span class="line">p.start()</span><br><span class="line">print(<span class="string">"is_alive() :&#123;&#125;"</span>.format(p.is_alive()))</span><br><span class="line">print(<span class="string">"p.exitcode: &#123;&#125;"</span>.format(p.exitcode))</span><br><span class="line">p.join()</span><br><span class="line">print(<span class="string">"is_alive() :&#123;&#125;"</span>.format(p.is_alive()))</span><br><span class="line">print(<span class="string">"p.exitcode: &#123;&#125;"</span>.format(p.exitcode))</span><br><span class="line">print(<span class="string">"p.name :&#123;&#125;"</span>.format(p.name))</span><br><span class="line">print(<span class="string">"p.pid :&#123;&#125;"</span>.format(p.pid))</span><br><span class="line">print(<span class="string">"我是主进程"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">is_alive() :True</span><br><span class="line">p.exitcode: None</span><br><span class="line">msg:10086  time:Sun Mar 31 22:04:38 2019   pid：22796 ppid:10980</span><br><span class="line">is_alive() :False</span><br><span class="line">p.exitcode: 0</span><br><span class="line">p.name :Myprocess-1</span><br><span class="line">p.pid :22796</span><br><span class="line">我是主进程</span><br></pre></td></tr></table></figure>
</li>
<li><p>setDaemon()方法。主进程A中，创建了子进程B，并且在主进程A中调用了B.setDaemon()，这个的意思是，把主进程A设置为守护进程，这时候，要是主进程A执行结束了，就不管子进程B是否完成，一并和进程程A退出.这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置，默认False</p>
</li>
<li><p>代码，例1：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.......</span><br><span class="line">p = Myprocess(msg=<span class="number">10086</span>)</span><br><span class="line">p.daemon = <span class="keyword">True</span></span><br><span class="line">p.start()</span><br><span class="line"><span class="comment"># p.join()</span></span><br><span class="line">print(<span class="string">"我是主进程"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>输出1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我是主进程</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>代码，例2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">........</span><br><span class="line">p = Myprocess(msg=<span class="number">10086</span>)</span><br><span class="line"> <span class="comment"># p.daemon = True</span></span><br><span class="line"> p.start()</span><br><span class="line"> <span class="comment"># p.join()</span></span><br><span class="line"> print(<span class="string">"我是主进程"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>输出2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我是主进程</span><br><span class="line">msg:10086  time:Sun Mar 31 22:21:34 2019   pid：6788 ppid:556</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="2-3-Pool类"><a href="#2-3-Pool类" class="headerlink" title="2.3 Pool类"></a>2.3 Pool类</h5><blockquote>
<p>进程池内部维护一个进程序列，当使用时，则去进程池中获取一个进程，如果进程池序列中没有可供使用的进进程，那么程序就会等待，直到进程池中有可用进程为止。进程池设置最好等于CPU核心数量</p>
<p><strong>构造方法：</strong></p>
<p>Pool([processes[, initializer[, initargs[, maxtasksperchild[, context]]]]])</p>
<p><strong>processes</strong> ：使用的工作进程的数量，如果processes是None那么使用 os.cpu_count()返回的数量。<br><strong>initializer：</strong> 如果initializer是None，那么每一个工作进程在开始的时候会调用initializer(*initargs)。<br><strong>maxtasksperchild：</strong>工作进程退出之前可以完成的任务数，完成后用一个新的工作进程来替代原进程，来让闲置的资源被释放。maxtasksperchild默认是None，意味着只要Pool存在工作进程就会一直存活。<br><strong>context:</strong> 用在制定工作进程启动时的上下文，一般使用 multiprocessing.Pool() 或者一个context对象的Pool()方法来创建一个池，两种方法都适当的设置了context</p>
<p><strong>实例方法：</strong></p>
<p>　　<strong>apply(func[, args[, kwds]])：同步进程池</strong></p>
<p>　　<strong>apply_async(func[, args[, kwds[, callback[, error_callback]]]]) ：异步进程池</strong></p>
<p>　　close() ： 关闭进程池，阻止更多的任务提交到pool，待任务完成后，工作进程会退出。</p>
<p>　　terminate() ： 结束工作进程，不在处理未完成的任务</p>
<p>　　join() : wait工作线程的退出，在调用join()前，必须调用close() or terminate()。这样是因为被终止的进程需要被父进程调用wait（join等价与wait），否则进程会成为僵尸进程。pool.join()必须使用在</p>
</blockquote>
<ul>
<li><p>进程池异步：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">out</span><span class="params">(msg)</span>:</span></span><br><span class="line">    s = random.randint(<span class="number">1</span>, <span class="number">3</span>) <span class="comment">#随机延时</span></span><br><span class="line">    time.sleep(s)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"msg:&#123;&#125;  time:&#123;&#125;   pid：&#123;&#125; ppid:&#123;&#125;"</span>.format(msg, time.asctime(time.localtime(time.time())), os.getpid(), os.getppid())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(arg)</span>:</span></span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">que</span><span class="params">()</span>:</span></span><br><span class="line">    Queue = queue.Queue()<span class="comment">#创建队列 先进先出</span></span><br><span class="line">    <span class="keyword">for</span> q <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        Queue.put(q)</span><br><span class="line">    <span class="keyword">return</span> Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    Que = que()</span><br><span class="line">    pool = multiprocessing.Pool(processes=multiprocessing.cpu_count())<span class="comment">#取最大CPU数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        pool.apply_async(func=out, args=(Que.get(),), callback=callback) <span class="comment">#callback自动接收func返回来的内容</span></span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()  <span class="comment"># 进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭</span></span><br><span class="line">    print(<span class="string">"我是主进程"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>控制台输出：总时间短，且执行顺序乱，非阻塞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">msg:2  time:Sun Mar 31 22:35:44 2019   pid：23020 ppid:16652</span><br><span class="line">msg:3  time:Sun Mar 31 22:35:44 2019   pid：26476 ppid:16652</span><br><span class="line">msg:6  time:Sun Mar 31 22:35:44 2019   pid：26204 ppid:16652</span><br><span class="line">msg:7  time:Sun Mar 31 22:35:44 2019   pid：17256 ppid:16652</span><br><span class="line">msg:0  time:Sun Mar 31 22:35:45 2019   pid：26980 ppid:16652</span><br><span class="line">msg:4  time:Sun Mar 31 22:35:45 2019   pid：10248 ppid:16652</span><br><span class="line">msg:1  time:Sun Mar 31 22:35:46 2019   pid：23180 ppid:16652</span><br><span class="line">msg:5  time:Sun Mar 31 22:35:46 2019   pid：22796 ppid:16652</span><br><span class="line">msg:8  time:Sun Mar 31 22:35:47 2019   pid：23020 ppid:16652</span><br><span class="line">msg:9  time:Sun Mar 31 22:35:47 2019   pid：26476 ppid:16652</span><br><span class="line">我是主进程</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>进程池同步：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">out</span><span class="params">(msg)</span>:</span></span><br><span class="line">    s = random.randint(<span class="number">1</span>, <span class="number">3</span>) <span class="comment">#随机延时</span></span><br><span class="line">    time.sleep(s)</span><br><span class="line">    print(<span class="string">"msg:&#123;&#125;  time:&#123;&#125;   pid：&#123;&#125; ppid:&#123;&#125;"</span>.format(msg, time.asctime(time.localtime(time.time())), os.getpid(), os.getppid()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">que</span><span class="params">()</span>:</span></span><br><span class="line">    Queue = queue.Queue()<span class="comment">#创建队列 先进先出</span></span><br><span class="line">    <span class="keyword">for</span> q <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        Queue.put(q)</span><br><span class="line">    <span class="keyword">return</span> Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    Que = que()</span><br><span class="line">    pool = multiprocessing.Pool(processes=multiprocessing.cpu_count())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        pool.apply(func=out, args=(Que.get(),)) <span class="comment">#callback自动接收func返回来的内容</span></span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()  <span class="comment"># 进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭</span></span><br><span class="line">    print(<span class="string">"我是主进程"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>控制台输出：总时间长，顺序执行，阻塞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">msg:0  time:Sun Mar 31 22:40:36 2019   pid：24072 ppid:13240</span><br><span class="line">msg:1  time:Sun Mar 31 22:40:37 2019   pid：13552 ppid:13240</span><br><span class="line">msg:2  time:Sun Mar 31 22:40:40 2019   pid：13736 ppid:13240</span><br><span class="line">msg:3  time:Sun Mar 31 22:40:43 2019   pid：8040 ppid:13240</span><br><span class="line">msg:4  time:Sun Mar 31 22:40:46 2019   pid：12532 ppid:13240</span><br><span class="line">msg:5  time:Sun Mar 31 22:40:48 2019   pid：24272 ppid:13240</span><br><span class="line">msg:6  time:Sun Mar 31 22:40:49 2019   pid：14028 ppid:13240</span><br><span class="line">msg:7  time:Sun Mar 31 22:40:52 2019   pid：22340 ppid:13240</span><br><span class="line">msg:8  time:Sun Mar 31 22:40:55 2019   pid：24072 ppid:13240</span><br><span class="line">msg:9  time:Sun Mar 31 22:40:56 2019   pid：13552 ppid:13240</span><br><span class="line">我是主进程</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>如果动作函数是带返回值的不仅可以使用callback输出还可以使用get()方法</p>
</li>
<li><p>错误的get使用方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">out</span><span class="params">(msg)</span>:</span></span><br><span class="line">    s = random.randint(<span class="number">1</span>, <span class="number">3</span>) <span class="comment">#随机延时</span></span><br><span class="line">    time.sleep(s)</span><br><span class="line">    print(<span class="string">"msg:&#123;&#125;  time:&#123;&#125;   pid：&#123;&#125; ppid:&#123;&#125;"</span>.format(msg, time.asctime(time.localtime(time.time())), os.getpid(), os.getppid()))</span><br><span class="line">    <span class="keyword">return</span> msg</span><br><span class="line">  ... ..... .........省略........</span><br><span class="line">    <span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    Que = que()</span><br><span class="line">    pool = multiprocessing.Pool(processes=multiprocessing.cpu_count())</span><br><span class="line">    l = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        r = pool.apply_async(func=out, args=(Que.get(),)) </span><br><span class="line">        print(r.get())</span><br><span class="line">        <span class="comment"># l.append(r)</span></span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()  <span class="comment"># 进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭</span></span><br><span class="line">    <span class="comment"># for i in l:</span></span><br><span class="line">    <span class="comment">#     print(i.get())</span></span><br><span class="line">    print(<span class="string">"我是主进程"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>控制台输出：顺讯执行，时间长，阻塞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">msg:0  time:Sun Mar 31 22:49:22 2019   pid：15668 ppid:13468</span><br><span class="line">0</span><br><span class="line">msg:1  time:Sun Mar 31 22:49:24 2019   pid：5968 ppid:13468</span><br><span class="line">1</span><br><span class="line">msg:2  time:Sun Mar 31 22:49:25 2019   pid：25524 ppid:13468</span><br><span class="line">2</span><br><span class="line">msg:3  time:Sun Mar 31 22:49:28 2019   pid：14148 ppid:13468</span><br><span class="line">3</span><br><span class="line">msg:4  time:Sun Mar 31 22:49:31 2019   pid：15240 ppid:13468</span><br><span class="line">4</span><br><span class="line">msg:5  time:Sun Mar 31 22:49:32 2019   pid：22544 ppid:13468</span><br><span class="line">5</span><br><span class="line">msg:6  time:Sun Mar 31 22:49:35 2019   pid：5364 ppid:13468</span><br><span class="line">6</span><br><span class="line">msg:7  time:Sun Mar 31 22:49:37 2019   pid：24740 ppid:13468</span><br><span class="line">7</span><br><span class="line">msg:8  time:Sun Mar 31 22:49:40 2019   pid：15668 ppid:13468</span><br><span class="line">8</span><br><span class="line">msg:9  time:Sun Mar 31 22:49:43 2019   pid：5968 ppid:13468</span><br><span class="line">9</span><br><span class="line">我是主进程</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>错误的get使用方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...........................</span><br><span class="line">    Que = que()</span><br><span class="line">    pool = multiprocessing.Pool(processes=multiprocessing.cpu_count())</span><br><span class="line">    l = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        r = pool.apply_async(func=out, args=(Que.get(),)) <span class="comment">#callback自动接收func返回来的内容</span></span><br><span class="line">        <span class="comment"># print(r.get())</span></span><br><span class="line">        l.append(r)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()  <span class="comment"># 进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">        print(i.get())</span><br><span class="line">    print(<span class="string">"我是主进程"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>控制台输出：顺序错乱，总时间短，非阻塞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">msg:6  time:Sun Mar 31 22:53:28 2019   pid：8600 ppid:25532</span><br><span class="line">msg:1  time:Sun Mar 31 22:53:29 2019   pid：5960 ppid:25532</span><br><span class="line">msg:0  time:Sun Mar 31 22:53:29 2019   pid：24544 ppid:25532</span><br><span class="line">msg:3  time:Sun Mar 31 22:53:29 2019   pid：15672 ppid:25532</span><br><span class="line">msg:4  time:Sun Mar 31 22:53:29 2019   pid：21808 ppid:25532</span><br><span class="line">msg:8  time:Sun Mar 31 22:53:29 2019   pid：8600 ppid:25532</span><br><span class="line">msg:7  time:Sun Mar 31 22:53:29 2019   pid：19028 ppid:25532</span><br><span class="line">msg:2  time:Sun Mar 31 22:53:30 2019   pid：9820 ppid:25532</span><br><span class="line">msg:5  time:Sun Mar 31 22:53:30 2019   pid：12736 ppid:25532</span><br><span class="line">msg:9  time:Sun Mar 31 22:53:32 2019   pid：24544 ppid:25532</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">我是主进程</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="2-4-数据共享"><a href="#2-4-数据共享" class="headerlink" title="2.4 数据共享"></a>2.4 数据共享</h5><blockquote>
<p>进程各自持有一份数据，默认无法共享数据</p>
</blockquote>
<ul>
<li><p>Array()实现：</p>
<ul>
<li>C语言参数类型对照</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">‘c’: ctypes.c_char　 ‘u’: ctypes.c_wchar　　‘b’: ctypes.c_byte　　　 ‘B’: ctypes.c_ubyte</span><br><span class="line">‘h’: ctypes.c_short　‘H’: ctypes.c_ushort　‘i’: ctypes.c_int　　　　　‘I’: ctypes.c_uint</span><br><span class="line">‘l’: ctypes.c_long,　‘L’: ctypes.c_ulong　　‘f’: ctypes.c_float　　‘d’: ctypes.c_double</span><br></pre></td></tr></table></figure>
<ul>
<li><p>代码块和输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Array</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a)</span>:</span></span><br><span class="line">    a[<span class="number">0</span>] = a[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = Array(<span class="string">'u'</span>, <span class="string">"Hello World"</span>)</span><br><span class="line">    p = Process(target=f, args=(arr,))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    print(arr[:])</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    -----控制台输出------</span><br><span class="line">    </span><br><span class="line">    dello World</span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Manager()实现：</p>
<blockquote>
<p>Manager()返回的manager提供list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Barrier, Queue, Value and Array类型的支持</p>
</blockquote>
</li>
<li><p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Manager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(d, l)</span>:</span></span><br><span class="line">    d[<span class="number">1</span>] = <span class="string">'1'</span></span><br><span class="line">    d[<span class="string">'2'</span>] = <span class="number">2</span></span><br><span class="line">    d[<span class="number">0.25</span>] = <span class="keyword">None</span></span><br><span class="line">    l.reverse()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    manager = Manager()</span><br><span class="line"></span><br><span class="line">    d = manager.dict()</span><br><span class="line">    l = manager.list(range(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">    p = Process(target=f, args=(d, l))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line">    print(d)</span><br><span class="line">    print(l)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;1: &apos;1&apos;, &apos;2&apos;: 2, 0.25: None&#125;</span><br><span class="line">[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="2-5-Lock互斥锁"><a href="#2-5-Lock互斥锁" class="headerlink" title="2.5 Lock互斥锁"></a>2.5 Lock互斥锁</h5><blockquote>
<p>当多个进程需要访问共享资源的时候，Lock可以用来避免访问的冲突</p>
</blockquote>
<blockquote>
<p><strong>进程之间数据隔离，但是共享一套文件系统，因而可以通过文件来实现进程直接的通信，但问题是必须自己加锁处理。</strong></p>
<p>注意：加锁的目的是为了保证多个进程修改同一块数据时，同一时间只能有一个修改，即串行的修改，没错，速度是慢了，牺牲了速度而保证了数据安全</p>
</blockquote>
<ul>
<li><p>代码实例，不加锁：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Lock</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(lock, i)</span>:</span></span><br><span class="line">    <span class="comment"># lock.acquire()</span></span><br><span class="line">    file(i)</span><br><span class="line">    read()</span><br><span class="line">    <span class="comment"># lock.release()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"test.txt"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"test.txt"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        line = f.readline()</span><br><span class="line">        print(<span class="string">"a: &#123;&#125; "</span>.format(line))</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    lock = Lock()</span><br><span class="line">    file(str(<span class="number">0</span>))</span><br><span class="line">    read()</span><br><span class="line">    <span class="keyword">for</span>  i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p = Process(target=write, args=(lock, str(i)))</span><br><span class="line">        p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">"我是主进程"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>控制台输出：可见有几次读到的都是0，表明某个时刻几个进程都同时去访问了该文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a: 0 </span><br><span class="line">a: 2 </span><br><span class="line">a: 0 </span><br><span class="line">a: 0 </span><br><span class="line">a: 3 </span><br><span class="line">a: 5 </span><br><span class="line">a: 4 </span><br><span class="line">a: 6 </span><br><span class="line">a: 7 </span><br><span class="line">a: 8 </span><br><span class="line">a: 9 </span><br><span class="line">我是主进程</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>代码实例，加锁：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">..........</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(lock, i)</span>:</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    file(i)</span><br><span class="line">    read()</span><br><span class="line">    lock.release()</span><br><span class="line">...........</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a: 0 </span><br><span class="line">a: 1 </span><br><span class="line">a: 0 </span><br><span class="line">a: 2 </span><br><span class="line">a: 3 </span><br><span class="line">a: 4 </span><br><span class="line">a: 6 </span><br><span class="line">a: 5 </span><br><span class="line">a: 7 </span><br><span class="line">a: 8 </span><br><span class="line">a: 9 </span><br><span class="line">我是主进程</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="2-6-Semaphore"><a href="#2-6-Semaphore" class="headerlink" title="2.6 Semaphore"></a>2.6 <strong>Semaphore</strong></h5><p>用来控制对共享资源的访问数量</p>
<ul>
<li><p>普通代码示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="comment"># s.acquire()</span></span><br><span class="line">    print(multiprocessing.current_process().name + <span class="string">"acquire"</span>)</span><br><span class="line">    time.sleep(i)</span><br><span class="line">    print(multiprocessing.current_process().name + <span class="string">"release\n"</span>)</span><br><span class="line">    <span class="comment"># s.release()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># s = multiprocessing.Semaphore(2)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p = multiprocessing.Process(target = worker, args=(i*<span class="number">2</span>, ))</span><br><span class="line">        p.start(）</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>控制台输出：观察换行，可以看出同一时段，会有很多进程都在访问这个worke函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Process-1acquire</span><br><span class="line">Process-2acquire</span><br><span class="line">Process-1release</span><br><span class="line"></span><br><span class="line">Process-3acquire</span><br><span class="line">Process-4acquire</span><br><span class="line">Process-5acquire</span><br><span class="line">Process-7acquire</span><br><span class="line">Process-6acquire</span><br><span class="line">Process-8acquire</span><br><span class="line">Process-9acquire</span><br><span class="line">Process-10acquire</span><br><span class="line">Process-2release</span><br><span class="line"></span><br><span class="line">Process-3release</span><br><span class="line"></span><br><span class="line">Process-4release</span><br><span class="line"></span><br><span class="line">Process-5release</span><br><span class="line"></span><br><span class="line">Process-6release</span><br><span class="line"></span><br><span class="line">Process-7release</span><br><span class="line"></span><br><span class="line">Process-8release</span><br><span class="line"></span><br><span class="line">Process-9release</span><br><span class="line"></span><br><span class="line">Process-10release</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>用Semaphore代码实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2019/3/31 10:42</span></span><br><span class="line"><span class="comment"># @Author  : YuChou</span></span><br><span class="line"><span class="comment"># @Site    : </span></span><br><span class="line"><span class="comment"># @File    : examp.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(i,s)</span>:</span></span><br><span class="line">    s.acquire()</span><br><span class="line">    print(multiprocessing.current_process().name + <span class="string">"acquire"</span>)</span><br><span class="line">    time.sleep(i)</span><br><span class="line">    print(multiprocessing.current_process().name + <span class="string">"release\n"</span>)</span><br><span class="line">    s.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    s = multiprocessing.Semaphore(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p = multiprocessing.Process(target = worker, args=(i*<span class="number">2</span>, s))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>控制台输出：观察换行，可以看出同时并存最多只有两个进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Process-3acquire</span><br><span class="line">Process-1acquire</span><br><span class="line">Process-1release</span><br><span class="line"></span><br><span class="line">Process-4acquire</span><br><span class="line">Process-3release</span><br><span class="line"></span><br><span class="line">Process-2acquire</span><br><span class="line">Process-2release</span><br><span class="line"></span><br><span class="line">Process-5acquire</span><br><span class="line">Process-4release</span><br><span class="line"></span><br><span class="line">Process-6acquire</span><br><span class="line">Process-5release</span><br><span class="line"></span><br><span class="line">Process-7acquire</span><br><span class="line">Process-6release</span><br><span class="line"></span><br><span class="line">Process-8acquire</span><br><span class="line">Process-7release</span><br><span class="line"></span><br><span class="line">Process-9acquire</span><br><span class="line">Process-8release</span><br><span class="line"></span><br><span class="line">Process-10acquire</span><br><span class="line">Process-9release</span><br><span class="line"></span><br><span class="line">Process-10release</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="2-7-Event"><a href="#2-7-Event" class="headerlink" title="2.7 Event"></a>2.7 Event</h5><blockquote>
<p>用于进程间通信，即程序中的其一个线程需要通过判断某个进程的状态来确定自己下一步的操作，就用到了event对象</p>
<p>event对象默认为假（Flase），即遇到event对象在等待就阻塞线程的执行</p>
<p>可以通过is_set()查看当前状态</p>
</blockquote>
<ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.wait()    #括号里可以带数字执行，数字表示等待的秒数，不带数字表示一直阻塞状态</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.set()     #默认为False，set一次表示True，所以子线程里的foo函数解除阻塞状态继续执行</span><br></pre></td></tr></table></figure>
</li>
<li><p>主进程和子进程之间的通信：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">child</span><span class="params">(even)</span>:</span></span><br><span class="line">    print(<span class="string">"start child....."</span>)</span><br><span class="line">    even.wait()</span><br><span class="line">    print(<span class="string">"end child....."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    </span><br><span class="line">    even = multiprocessing.Event()</span><br><span class="line">    p = multiprocessing.Process(target=child, args=(even,))</span><br><span class="line">    p.start()</span><br><span class="line">    print(<span class="string">"主进程等待...."</span>)</span><br><span class="line">    time.sleep(<span class="number">4</span>)</span><br><span class="line">    print(<span class="string">"主进程结束等待"</span>)</span><br><span class="line">    even.set()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>控制台输出：可以看出，子进程一直在等set</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主进程等待....</span><br><span class="line">start child.....</span><br><span class="line">主进程结束等待</span><br><span class="line">end child.....</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>给与wait值为2s</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">child</span><span class="params">(even, s)</span>:</span></span><br><span class="line">    print(<span class="string">"start child....."</span>)</span><br><span class="line">    even.wait(s)</span><br><span class="line">    print(<span class="string">"end child....."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    even = multiprocessing.Event()</span><br><span class="line">    p = multiprocessing.Process(target=child, args=(even,<span class="number">2</span>))</span><br><span class="line">    p.start()</span><br><span class="line">    print(<span class="string">"主进程等待...."</span>)</span><br><span class="line">    time.sleep(<span class="number">4</span>)</span><br><span class="line">    print(<span class="string">"主进程结束等待"</span>)</span><br><span class="line">    even.set()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>控制台输出：可见并没有等待set, 子进程已经解除阻塞了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主进程等待....</span><br><span class="line">start child.....</span><br><span class="line">end child.....</span><br><span class="line">主进程结束等待</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>当然也可以用在子进程与子进程之间，不详解</li>
</ul>
<h5 id="2-8-Queue"><a href="#2-8-Queue" class="headerlink" title="2.8 Queue"></a>2.8 Queue</h5><blockquote>
<p>Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。put方法用以插入数据到队列中，put方法还有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，该方法会阻塞timeout指定的时间，直到该队列有剩余的空间。如果超时，会抛出Queue.Full异常。如果blocked为False，但该Queue已满，会立即抛出Queue.Full异常。</p>
<p>get方法可以从队列读取并且删除一个元素。同样，get方法有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，那么在等待时间内没有取到任何元素，会抛出Queue.Empty异常。如果blocked为False，有两种情况存在，如果Queue有一个值可用，则立即返回该值，否则，如果队列为空，则立即抛出Queue.Empty异常。Queue的一段示例代码：</p>
</blockquote>
<ul>
<li><p>代码块：来源<a href="https://www.cnblogs.com/kaituorensheng/p/4445418.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/kaituorensheng/p/4445418.html" target="_blank" rel="noopener">https://www.cnblogs.com/kaituorensheng/p/4445418.html</a></a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer_proc</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        q.put(<span class="number">1</span>, block = <span class="keyword">False</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader_proc</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(q.get(block = <span class="keyword">False</span>))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    q = multiprocessing.Queue()</span><br><span class="line">    writer = multiprocessing.Process(target=writer_proc, args=(q,))</span><br><span class="line">    writer.start()</span><br><span class="line"></span><br><span class="line">    reader = multiprocessing.Process(target=reader_proc, args=(q,))</span><br><span class="line">    reader.start()</span><br><span class="line"></span><br><span class="line">    reader.join()</span><br><span class="line">    writer.join()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>控制台输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="2-9-Pipe"><a href="#2-9-Pipe" class="headerlink" title="2.9 Pipe"></a>2.9 Pipe</h5><blockquote>
<p>Pipe方法返回(conn1, conn2)代表一个管道的两个端。Pipe方法有duplex参数，如果duplex参数为True(默认值)，那么这个管道是全双工模式，也就是说conn1和conn2均可收发。duplex为False，conn1只负责接受消息，conn2只负责发送消息。</p>
<p>send和recv方法分别是发送和接受消息的方法。例如，在全双工模式下，可以调用conn1.send发送消息，conn1.recv接收消息。如果没有消息可接收，recv方法会一直阻塞。如果管道已经被关闭，那么recv方法会抛出EOFError。close方法表示关闭管道，当消息接收结束以后，关闭管道。</p>
</blockquote>
<ul>
<li><p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pro</span><span class="params">(p)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p.send(i)</span><br><span class="line">        print(<span class="string">"我发啦"</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cou</span><span class="params">(c)</span>:</span></span><br><span class="line">    n=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt;= <span class="number">9</span>:</span><br><span class="line">       print(c.recv())</span><br><span class="line">       print(<span class="string">"我收啦\n"</span>)</span><br><span class="line">       time.sleep(<span class="number">1</span>)</span><br><span class="line">       n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    p, c = multiprocessing.Pipe()</span><br><span class="line">    m1 = multiprocessing.Process(target=pro, args=(p,))</span><br><span class="line">    m2 = multiprocessing.Process(target=cou, args=(c,))</span><br><span class="line">    m1.start()</span><br><span class="line">    m2.start()</span><br><span class="line">    m1.join()</span><br><span class="line">    m2.join()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>控制台输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">我发啦</span><br><span class="line">0</span><br><span class="line">我收啦</span><br><span class="line"></span><br><span class="line">我发啦</span><br><span class="line">1</span><br><span class="line">我收啦</span><br><span class="line"></span><br><span class="line">我发啦</span><br><span class="line">2</span><br><span class="line">我收啦</span><br><span class="line"></span><br><span class="line">我发啦</span><br><span class="line">3</span><br><span class="line">我收啦</span><br><span class="line"></span><br><span class="line">我发啦</span><br><span class="line">4</span><br><span class="line">我收啦</span><br><span class="line"></span><br><span class="line">我发啦</span><br><span class="line">5</span><br><span class="line">我收啦</span><br><span class="line"></span><br><span class="line">我发啦</span><br><span class="line">6</span><br><span class="line">我收啦</span><br><span class="line"></span><br><span class="line">我发啦</span><br><span class="line">7</span><br><span class="line">我收啦</span><br><span class="line"></span><br><span class="line">我发啦</span><br><span class="line">8</span><br><span class="line">我收啦</span><br><span class="line"></span><br><span class="line">我发啦</span><br><span class="line">9</span><br><span class="line">我收啦</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="2-10-subprocess三方模块"><a href="#2-10-subprocess三方模块" class="headerlink" title="2.10 subprocess三方模块"></a>2.10 subprocess三方模块</h5><blockquote>
<p>很多时候，子进程并不是自身，而是一个外部进程。我们创建了子进程后，还需要控制子进程的输入和输出。</p>
<p><code>subprocess</code>模块可以让我们非常方便地启动一个子进程，然后控制其输入和输出。</p>
</blockquote>
<ul>
<li><p>代码块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">r = subprocess.call([<span class="string">"python"</span>, <span class="string">"--version"</span>]) <span class="comment">#命令行空格用 ','隔开</span></span><br><span class="line">print(<span class="string">'console:'</span>, r)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Python 3.6.5 :: Anaconda, Inc.</span><br><span class="line">console: 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>参考链接：<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431927781401bb47ccf187b24c3b955157bb12c5882d000" target="_blank" rel="noopener"><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431927781401bb47ccf187b24c3b955157bb12c5882d000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431927781401bb47ccf187b24c3b955157bb12c5882d000</a></a></p>
<p><a href="https://www.cnblogs.com/kaituorensheng/p/4445418.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/kaituorensheng/p/4445418.html" target="_blank" rel="noopener">https://www.cnblogs.com/kaituorensheng/p/4445418.html</a></a></p>
<p><a href="https://www.cnblogs.com/UncleYong/p/6987112.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/UncleYong/p/6987112.html" target="_blank" rel="noopener">https://www.cnblogs.com/UncleYong/p/6987112.html</a></a></p>
<p><a href="https://www.cnblogs.com/haiyan123/p/7429568.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/haiyan123/p/7429568.html" target="_blank" rel="noopener">https://www.cnblogs.com/haiyan123/p/7429568.html</a></a></p>
<p><a href="https://www.cnblogs.com/lidagen/p/7252247.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/lidagen/p/7252247.html" target="_blank" rel="noopener">https://www.cnblogs.com/lidagen/p/7252247.html</a></a></p>
<p><a href="https://blog.51cto.com/286577399/2051155" target="_blank" rel="noopener"><a href="https://blog.51cto.com/286577399/2051155" target="_blank" rel="noopener">https://blog.51cto.com/286577399/2051155</a></a></p>
<hr>
<p>2019/04/01 22:26</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/31/Python多进程/" data-id="cju74b0vj0000mghz7mtmttdc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多进程/">多进程</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/04/05/Python多线程/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Python多线程
        
      </div>
    </a>
  
  
    <a href="/2019/03/26/robotframework进阶指南/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">robotframework进阶指南</div>
    </a>
  
</nav>

  
</article>



</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">YuChou</h1>
    <h2 class="blog-subtitle">Dream of walking the world with techbology</h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives/" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories/" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags/" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="http://149.248.3.74/Photos/titleImage/AF359E06C1819F0FA30D32DA9F0E8EB6.png">
    <h2 class="author">YuChou</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>15</strong><br>文章</div></a>
      <a href="/categories"><div><strong>10</strong><br>分类</div></a>
      <a href="/tags"><div><strong>15</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="https://github.com/mrzhouyu" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>SomeLink</h2>
      
        <a class="hvr-bounce-in" href="https://www.zhihu.com" target="_blank" title="Zhihu">
          Zhihu
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2018 - 2019 YuChou<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a href="https://github.com/ShanaMaid/hexo-theme-shana">Shana</a>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  <link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">
  <script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>



  <link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">
  <script src="/plugin/galmenu/GalMenu.js"></script>
  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/tags" title="" class="menuItem">标签</a>
          
            <a href="/categories" title="" class="menuItem">分类</a>
          
            <a href="/archives" title="" class="menuItem">归档</a>
          
            <a href="/xxxxxxxxx" title="" class="menuItem">xxx</a>
          
            <a href="/xxxxxxx" title="" class="menuItem">xxxx</a>
          
        </div>
        
          <audio id="audio" src="#"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>
<script src="/js/script.js"></script>



  </div>
</body>
</html>